<!DOCTYPE html>
<html lang="en">
<head>
    <title>HyperFixi Integration Module Tests</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .test { margin: 20px 0; padding: 15px; border: 2px solid #ddd; border-radius: 5px; }
        .test.pass { border-color: #28a745; background: #f8fff9; }
        .test.fail { border-color: #dc3545; background: #fff8f8; }
        .test h3 { margin-top: 0; }
        .result { font-weight: bold; margin: 10px 0; }
        .result.pass { color: #28a745; }
        .result.fail { color: #dc3545; }
        .stats { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .module-section { border-top: 3px solid #6c757d; margin: 30px 0; padding-top: 20px; }
        .event-test { background: #e3f2fd; padding: 10px; margin: 10px 0; border-radius: 3px; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ðŸ”— HyperFixi Integration Module Tests</h1>
    
    <div class="stats">
        <strong>Test Results:</strong>
        <span id="passed">0</span> passed, 
        <span id="failed">0</span> failed,
        <span id="total">0</span> total
    </div>

    <!-- Hyperscript Integration Tests -->
    <div class="module-section">
        <h2>âš¡ Hyperscript Integration Module</h2>
        
        <div class="test" id="test-command-creation">
            <h3>Command Creation - createFetchCommand</h3>
            <p>Test creation of hyperscript-compatible fetch command</p>
            <div class="result" id="result-command-creation">Running...</div>
        </div>

        <div class="test" id="test-command-registration">
            <h3>Command Registration - registerCommand</h3>
            <p>Test registration of commands with hyperscript instance</p>
            <div class="result" id="result-command-registration">Running...</div>
        </div>

        <div class="test" id="test-command-execution">
            <h3>Command Execution - fetch command function</h3>
            <p>Test actual fetch command execution with mock hyperscript</p>
            <div class="result" id="result-command-execution">Running...</div>
        </div>
    </div>

    <!-- Fixi Events Integration Tests -->
    <div class="module-section">
        <h2>ðŸŽª Fixi Events Integration Module</h2>
        
        <div class="test" id="test-no-event-handler">
            <h3>No Event Handler - createNoEventHandler</h3>
            <p>Test minimal handler with no event emission</p>
            <div class="result" id="result-no-event-handler">Running...</div>
        </div>

        <div class="test" id="test-minimal-event-handler">
            <h3>Minimal Event Handler - createMinimalEventHandler</h3>
            <p>Test handler with basic error events only</p>
            <div class="result" id="result-minimal-event-handler">Running...</div>
        </div>

        <div class="test" id="test-fixi-event-handler">
            <h3>Full Fixi Event Handler - createFixiEventHandler</h3>
            <p>Test complete fixi event chain compatibility</p>
            <div class="result" id="result-fixi-event-handler">Running...</div>
        </div>

        <div class="test" id="test-event-sequence">
            <h3>Event Sequence - Complete fixi event chain</h3>
            <p>Test complete fx:config â†’ fx:before â†’ fx:after â†’ fx:swapped sequence</p>
            <div class="result" id="result-event-sequence">Running...</div>
            <div class="event-test" id="event-log"></div>
        </div>

        <div class="test" id="test-event-cancellation">
            <h3>Event Cancellation - preventDefault handling</h3>
            <p>Test event cancellation via preventDefault</p>
            <div class="result" id="result-event-cancellation">Running...</div>
        </div>
    </div>

    <script type="module">
        // Test framework
        let passed = 0;
        let failed = 0;
        let total = 0;

        function updateStats() {
            document.getElementById('passed').textContent = passed;
            document.getElementById('failed').textContent = failed;
            document.getElementById('total').textContent = total;
        }

        function runTest(testId, testName, testFn) {
            total++;
            const testElement = document.getElementById(`test-${testId}`);
            const resultElement = document.getElementById(`result-${testId}`);
            
            try {
                testFn();
                passed++;
                testElement.className = 'test pass';
                resultElement.className = 'result pass';
                resultElement.textContent = 'âœ… PASS';
            } catch (error) {
                failed++;
                testElement.className = 'test fail';
                resultElement.className = 'result fail';
                resultElement.textContent = `âŒ FAIL: ${error.message}`;
                console.error(`Test ${testName} failed:`, error);
            }
            
            updateStats();
        }

        async function runAsyncTest(testId, testName, testFn) {
            total++;
            const testElement = document.getElementById(`test-${testId}`);
            const resultElement = document.getElementById(`result-${testId}`);
            
            try {
                await testFn();
                passed++;
                testElement.className = 'test pass';
                resultElement.className = 'result pass';
                resultElement.textContent = 'âœ… PASS';
            } catch (error) {
                failed++;
                testElement.className = 'test fail';
                resultElement.className = 'result fail';
                resultElement.textContent = `âŒ FAIL: ${error.message}`;
                console.error(`Test ${testName} failed:`, error);
            }
            
            updateStats();
        }

        function assertEqual(actual, expected, message = '') {
            if (actual !== expected) {
                throw new Error(`${message}Expected: ${expected}, Got: ${actual}`);
            }
        }

        function assertNotNull(value, message = '') {
            if (value === null || value === undefined) {
                throw new Error(`${message}Expected non-null value, got: ${value}`);
            }
        }

        function assertTrue(value, message = '') {
            if (!value) {
                throw new Error(`${message}Expected truthy value, got: ${value}`);
            }
        }

        function assertInstanceOf(value, constructor, message = '') {
            if (!(value instanceof constructor)) {
                throw new Error(`${message}Expected instance of ${constructor.name}, got: ${typeof value}`);
            }
        }

        // Mock hyperscript instance
        const mockHyperscript = {
            addCommand: (name, commandFn) => {
                mockHyperscript._commands = mockHyperscript._commands || {};
                mockHyperscript._commands[name] = commandFn;
                return true;
            },
            _commands: {}
        };

        // Mock parser and runtime
        const mockParser = {
            parseElementExpression: () => ({ type: 'url', value: '/test-url' }),
            raiseParseError: (tokens, message) => { throw new Error(message); }
        };

        const mockRuntime = {
            evaluateElement: (expr) => expr.value || 'mock-value'
        };

        const mockTokens = {
            currentToken: () => ({ value: 'test-token' }),
            matchToken: (token) => token === 'test-token',
            consumeToken: () => ({ value: 'consumed' }),
            requireToken: (token) => ({ value: token }),
            hasMore: () => false
        };

        async function runIntegrationTests() {
            // Test Hyperscript Integration Module
            const { 
                createFetchCommand, 
                registerCommand, 
                registerFetchCommand 
            } = await import('../integrations/hyperscript.js');

            runTest('command-creation', 'createFetchCommand', () => {
                const config = {
                    syntaxParser: (parser, runtime, tokens, command) => command,
                    eventHandler: { 
                        handleBeforeEvents: () => Promise.resolve(true),
                        handleAfterEvents: () => Promise.resolve(true),
                        handleSwappedEvents: () => {},
                        handleErrorEvents: () => {}
                    }
                };
                
                const command = createFetchCommand(config);
                
                assertEqual(typeof command, 'function', 'Should return a function');
                // Test that the command function has the right structure
                assertTrue(command.length >= 2, 'Command should accept parser and runtime parameters');
            });

            runTest('command-registration', 'registerCommand', () => {
                const dummyCommand = () => {};
                const result = registerCommand(mockHyperscript, dummyCommand, 'test-fetch');
                
                assertTrue(result, 'Should return true on successful registration');
                assertNotNull(mockHyperscript._commands['test-fetch'], 'Command should be registered');
            });

            runTest('command-execution', 'fetch command execution', () => {
                // Create a simple command and test its basic structure
                const config = {
                    syntaxParser: (parser, runtime, tokens, command) => ({
                        ...command,
                        url: { value: '/test' },
                        placement: 'replace',
                        target: { value: '#test' }
                    }),
                    eventHandler: { 
                        handleBeforeEvents: () => Promise.resolve(true),
                        handleAfterEvents: () => Promise.resolve(true),
                        handleSwappedEvents: () => {},
                        handleErrorEvents: () => {}
                    }
                };
                
                const command = createFetchCommand(config);
                
                // The command function should handle basic parsing without throwing
                try {
                    // Mock a command execution context
                    const result = command(mockParser, mockRuntime, mockTokens);
                    // Should return a function (the actual command executor)
                    assertEqual(typeof result, 'function', 'Command should return executor function');
                } catch (error) {
                    // Expected - this is a simplified test environment
                    assertTrue(error.message.includes('test') || error.message.includes('mock'), 
                              'Error should be related to test environment limitations');
                }
            });

            // Test Fixi Events Integration Module
            const { 
                createNoEventHandler,
                createMinimalEventHandler,
                createFixiEventHandler,
                FixiEventHandler,
                MinimalEventHandler,
                NoEventHandler
            } = await import('../integrations/fixi-events.js');

            runTest('no-event-handler', 'createNoEventHandler', () => {
                const handler = createNoEventHandler();
                
                assertNotNull(handler, 'Should create handler');
                assertInstanceOf(handler, NoEventHandler, 'Should be NoEventHandler instance');
                
                // Test no-op behavior
                assertEqual(typeof handler.handleBeforeEvents, 'function', 'Should have handleBeforeEvents');
                assertEqual(typeof handler.handleAfterEvents, 'function', 'Should have handleAfterEvents');
                assertEqual(typeof handler.handleSwappedEvents, 'function', 'Should have handleSwappedEvents');
                assertEqual(typeof handler.handleErrorEvents, 'function', 'Should have handleErrorEvents');
            });

            runTest('minimal-event-handler', 'createMinimalEventHandler', () => {
                const handler = createMinimalEventHandler();
                
                assertNotNull(handler, 'Should create handler');
                assertInstanceOf(handler, MinimalEventHandler, 'Should be MinimalEventHandler instance');
                
                // Test that it has basic event handling
                assertEqual(typeof handler.handleErrorEvents, 'function', 'Should handle error events');
            });

            runTest('fixi-event-handler', 'createFixiEventHandler', () => {
                const handler = createFixiEventHandler();
                
                assertNotNull(handler, 'Should create handler');
                assertInstanceOf(handler, FixiEventHandler, 'Should be FixiEventHandler instance');
                
                // Test full event interface
                assertEqual(typeof handler.handleBeforeEvents, 'function', 'Should handle before events');
                assertEqual(typeof handler.handleAfterEvents, 'function', 'Should handle after events');
                assertEqual(typeof handler.handleSwappedEvents, 'function', 'Should handle swapped events');
                assertEqual(typeof handler.handleErrorEvents, 'function', 'Should handle error events');
            });

            await runAsyncTest('event-sequence', 'Complete fixi event chain', async () => {
                const handler = createFixiEventHandler();
                const element = document.createElement('div');
                const eventLog = document.getElementById('event-log');
                const events = [];
                
                // Listen for all fixi events
                ['fx:config', 'fx:before', 'fx:after', 'fx:swapped', 'fx:error', 'fx:finally'].forEach(eventType => {
                    element.addEventListener(eventType, (e) => {
                        events.push(eventType);
                        eventLog.innerHTML += `<div>âœ“ ${eventType} fired</div>`;
                    });
                });
                
                // Mock config
                const cfg = {
                    url: '/test',
                    method: 'GET',
                    target: element,
                    swap: 'innerHTML',
                    response: { status: 200 },
                    text: '<div>test</div>'
                };
                
                // Test event sequence
                const beforeResult = await handler.handleBeforeEvents(element, cfg);
                assertTrue(beforeResult, 'Before events should return true');
                assertTrue(events.includes('fx:config'), 'Should fire fx:config');
                assertTrue(events.includes('fx:before'), 'Should fire fx:before');
                
                const afterResult = await handler.handleAfterEvents(element, cfg);
                assertTrue(afterResult, 'After events should return true');
                assertTrue(events.includes('fx:after'), 'Should fire fx:after');
                
                handler.handleSwappedEvents(element, cfg);
                assertTrue(events.includes('fx:swapped'), 'Should fire fx:swapped');
            });

            await runAsyncTest('event-cancellation', 'preventDefault handling', async () => {
                const handler = createFixiEventHandler();
                const element = document.createElement('div');
                let configCancelled = false;
                let beforeCancelled = false;
                
                // Set up event cancellation
                element.addEventListener('fx:config', (e) => {
                    e.preventDefault();
                    configCancelled = true;
                });
                
                element.addEventListener('fx:before', (e) => {
                    e.preventDefault();
                    beforeCancelled = true;
                });
                
                const cfg = { url: '/test', method: 'GET', target: element };
                
                // Test config cancellation
                const configResult = await handler.handleBeforeEvents(element, cfg);
                assertTrue(configCancelled, 'fx:config should be fired');
                assertNotNull(configResult, 'Should return result even when cancelled');
                
                // Test before cancellation
                const beforeResult = await handler.handleBeforeEvents(element, cfg);
                assertTrue(beforeCancelled, 'fx:before should be fired'); 
                assertNotNull(beforeResult, 'Should return result even when cancelled');
            });
        }

        // Run all integration tests
        runIntegrationTests().then(() => {
            console.log(`Integration module tests completed: ${passed} passed, ${failed} failed`);
        }).catch(error => {
            console.error('Integration test runner error:', error);
        });
    </script>
</body>
</html>