<!DOCTYPE html>
<html lang="en">
<head>
    <title>HyperFixi Core Module Tests</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .test { margin: 20px 0; padding: 15px; border: 2px solid #ddd; border-radius: 5px; }
        .test.pass { border-color: #28a745; background: #f8fff9; }
        .test.fail { border-color: #dc3545; background: #fff8f8; }
        .test h3 { margin-top: 0; }
        .result { font-weight: bold; margin: 10px 0; }
        .result.pass { color: #28a745; }
        .result.fail { color: #dc3545; }
        .stats { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ðŸ§ª HyperFixi Core Module Tests</h1>
    
    <div class="stats">
        <strong>Test Results:</strong>
        <span id="passed">0</span> passed, 
        <span id="failed">0</span> failed,
        <span id="total">0</span> total
    </div>

    <!-- Parser Module Tests -->
    <div class="test" id="test-parser-url">
        <h3>Core Parser - parseURL</h3>
        <p>Test that URL parsing works correctly with valid and invalid inputs</p>
        <div class="result" id="result-parser-url">Running...</div>
    </div>

    <div class="test" id="test-parser-base-command">
        <h3>Core Parser - createBaseCommand</h3>
        <p>Test that base command structure is created correctly</p>
        <div class="result" id="result-parser-base-command">Running...</div>
    </div>

    <!-- Executor Module Tests -->
    <div class="test" id="test-executor-http">
        <h3>Core Executor - executeHTTPRequest</h3>
        <p>Test HTTP request execution with mocked fetch</p>
        <div class="result" id="result-executor-http">Running...</div>
    </div>

    <div class="test" id="test-executor-config">
        <h3>Core Executor - createFixiConfig</h3>
        <p>Test fixi configuration object creation</p>
        <div class="result" id="result-executor-config">Running...</div>
    </div>

    <!-- DOM Module Tests -->
    <div class="test" id="test-dom-mapping">
        <h3>Core DOM - mapPlacementToSwap</h3>
        <p>Test placement keyword to swap strategy mapping</p>
        <div class="result" id="result-dom-mapping">Running...</div>
    </div>

    <div class="test" id="test-dom-swap">
        <h3>Core DOM - applySwap</h3>
        <p>Test DOM manipulation with different swap strategies</p>
        <div class="result" id="result-dom-swap">Running...</div>
    </div>

    <!-- Events Module Tests -->
    <div class="test" id="test-events-creation">
        <h3>Core Events - createCustomEvent</h3>
        <p>Test custom event creation with proper detail payload</p>
        <div class="result" id="result-events-creation">Running...</div>
    </div>

    <div class="test" id="test-events-emission">
        <h3>Core Events - emitEvent</h3>
        <p>Test event emission and cancellation</p>
        <div class="result" id="result-events-emission">Running...</div>
    </div>

    <!-- Load modules dynamically -->
    <script type="module">
        // Test framework
        let passed = 0;
        let failed = 0;
        let total = 0;

        function updateStats() {
            document.getElementById('passed').textContent = passed;
            document.getElementById('failed').textContent = failed;
            document.getElementById('total').textContent = total;
        }

        function runTest(testId, testName, testFn) {
            total++;
            const testElement = document.getElementById(`test-${testId}`);
            const resultElement = document.getElementById(`result-${testId}`);
            
            try {
                testFn();
                passed++;
                testElement.className = 'test pass';
                resultElement.className = 'result pass';
                resultElement.textContent = 'âœ… PASS';
            } catch (error) {
                failed++;
                testElement.className = 'test fail';
                resultElement.className = 'result fail';
                resultElement.textContent = `âŒ FAIL: ${error.message}`;
                console.error(`Test ${testName} failed:`, error);
            }
            
            updateStats();
        }

        function assertEqual(actual, expected, message = '') {
            if (actual !== expected) {
                throw new Error(`${message}Expected: ${expected}, Got: ${actual}`);
            }
        }

        function assertNotNull(value, message = '') {
            if (value === null || value === undefined) {
                throw new Error(`${message}Expected non-null value, got: ${value}`);
            }
        }

        function assertThrows(fn, message = '') {
            try {
                fn();
                throw new Error(`${message}Expected function to throw, but it didn't`);
            } catch (error) {
                if (error.message.includes('Expected function to throw')) {
                    throw error;
                }
                // Expected to throw, test passes
            }
        }

        // Mock hyperscript parser for testing
        const mockParser = {
            parseElementExpression: () => ({ type: 'url', value: '/test-url' }),
            raiseParseError: (tokens, message) => { throw new Error(message); }
        };

        const mockTokens = {
            matchToken: (token) => token === 'test-token',
            currentToken: () => ({ value: 'test-token' })
        };

        // Import and test core modules
        async function runCoreTests() {
            // Test Parser Module
            const { parseURL, createBaseCommand } = await import('../core/parser.js');
            
            runTest('parser-url', 'parseURL', () => {
                const result = parseURL(mockParser, mockTokens);
                assertNotNull(result, 'parseURL should return a result');
                assertEqual(result.type, 'url', 'parseURL should return URL expression');
            });

            runTest('parser-base-command', 'createBaseCommand', () => {
                const url = { type: 'url', value: '/test' };
                const command = createBaseCommand(url);
                assertEqual(command.url, url, 'Command should have URL');
                assertEqual(command.placement, null, 'Command should have null placement');
                assertEqual(command.target, null, 'Command should have null target');
                assertNotNull(command.options, 'Command should have options object');
            });

            // Test Executor Module
            const { createFixiConfig } = await import('../core/executor.js');
            
            runTest('executor-config', 'createFixiConfig', () => {
                const url = '/test';
                const options = { method: 'POST' };
                const element = document.createElement('div');
                const event = new Event('click');
                
                const config = createFixiConfig(url, options, element, event);
                assertEqual(config.url, url, 'Config should have URL');
                assertEqual(config.method, 'POST', 'Config should have method');
                assertEqual(config.target, element, 'Config should have target');
                assertEqual(config.trigger, event, 'Config should have trigger');
            });

            // Test DOM Module
            const { mapPlacementToSwap, applySwap, SWAP_STRATEGIES } = await import('../core/dom.js');
            
            runTest('dom-mapping', 'mapPlacementToSwap', () => {
                assertEqual(mapPlacementToSwap('replace'), SWAP_STRATEGIES.OUTER_HTML);
                assertEqual(mapPlacementToSwap('put into'), SWAP_STRATEGIES.INNER_HTML);
                assertEqual(mapPlacementToSwap('append to'), SWAP_STRATEGIES.BEFORE_END);
                assertEqual(mapPlacementToSwap('prepend to'), SWAP_STRATEGIES.AFTER_BEGIN);
            });

            runTest('dom-swap', 'applySwap', () => {
                const target = document.createElement('div');
                target.innerHTML = 'original';
                const content = 'new content';
                
                const result = applySwap(target, content, SWAP_STRATEGIES.INNER_HTML);
                assertEqual(result, true, 'applySwap should return true on success');
                assertEqual(target.innerHTML, content, 'Content should be updated');
            });

            // Test Events Module
            const { createCustomEvent, emitEvent, FIXI_EVENTS } = await import('../core/events.js');
            
            runTest('events-creation', 'createCustomEvent', () => {
                const detail = { test: 'data' };
                const event = createCustomEvent('test-event', detail);
                assertEqual(event.type, 'test-event', 'Event should have correct type');
                assertEqual(event.detail.test, 'data', 'Event should have detail payload');
                assertEqual(event.bubbles, true, 'Event should bubble by default');
                assertEqual(event.cancelable, true, 'Event should be cancelable by default');
            });

            runTest('events-emission', 'emitEvent', () => {
                const element = document.createElement('div');
                let eventReceived = false;
                
                element.addEventListener('test-emit', (e) => {
                    eventReceived = true;
                    assertEqual(e.detail.test, 'data', 'Event detail should be correct');
                });
                
                const result = emitEvent(element, 'test-emit', { test: 'data' });
                assertEqual(result, true, 'emitEvent should return true when not cancelled');
                assertEqual(eventReceived, true, 'Event should be received by listener');
            });

            // Mock HTTP test (simplified)
            runTest('executor-http', 'executeHTTPRequest', () => {
                // This test validates the structure since we can't easily mock fetch
                // In a real environment, we'd use a proper mocking framework
                
                // Test that the function exists and has correct signature
                const { executeHTTPRequest } = await import('../core/executor.js');
                assertEqual(typeof executeHTTPRequest, 'function', 'executeHTTPRequest should be a function');
                
                // Test parameter validation
                try {
                    executeHTTPRequest(); // Should handle missing URL gracefully
                } catch (error) {
                    // Expected behavior - function should handle errors
                }
            });
        }

        // Run all tests
        runCoreTests().then(() => {
            console.log(`Core module tests completed: ${passed} passed, ${failed} failed`);
        }).catch(error => {
            console.error('Test runner error:', error);
        });
    </script>
</body>
</html>