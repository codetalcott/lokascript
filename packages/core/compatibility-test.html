<!DOCTYPE html>
<html>
<head>
    <title>HyperScript Compatibility Test</title>

    <!-- Test Navigation -->
    <script src="test-nav.js"></script>
</head>
<body>
    <div id="work-area"></div>
    
    <!-- Original _hyperscript library (optional - gracefully handles missing) -->
    <script src="dist/_hyperscript.js" onerror="console.log('_hyperscript not available')"></script>

    <!-- Our hyperfixi implementation (relative path works from any server root) -->
    <script src="dist/hyperfixi-browser.js"></script>
    
    <script>
        // Setup compatibility helpers
        window.testResults = [];
        
        window.testExpression = async function(expression, context = {}) {
            try {
                // Use the correct API for both libraries
                let original, originalError;
                let ours, oursError;
                
                // Test _hyperscript
                try {
                    original = _hyperscript.evaluate(expression, context);
                } catch (err) {
                    originalError = err.message;
                }
                
                // Test hyperfixi
                try {
                    ours = await hyperfixi.evalHyperScript(expression, context);
                } catch (err) {
                    oursError = err.message;
                }
                
                // Both succeeded - compare values
                if (!originalError && !oursError) {
                    return { expression, original, ours, match: original === ours };
                }
                
                // Both failed - check if error messages are similar (compatibility)
                if (originalError && oursError) {
                    // For mixed operator errors, both should fail - that's compatible
                    const isMixedOperatorError = originalError.includes('parenthesize') || oursError.includes('parenthesize');
                    return { 
                        expression, 
                        original: `ERROR: ${originalError}`, 
                        ours: `ERROR: ${oursError}`, 
                        match: isMixedOperatorError 
                    };
                }
                
                // One succeeded, one failed - not compatible
                return { 
                    expression, 
                    original: originalError ? `ERROR: ${originalError}` : original, 
                    ours: oursError ? `ERROR: ${oursError}` : ours, 
                    match: false 
                };
                
            } catch (error) {
                return { expression, error: error.message, match: false };
            }
        };
        
        // Set up global evalHyperScript function for test compatibility
        window.evalHyperScript = async function(expression, context) {
            console.log('[evalHyperScript] Evaluating:', expression, 'context:', context);
            try {
                const result = await hyperfixi.evalHyperScript(expression, context);
                console.log('[evalHyperScript] Result:', result, 'type:', typeof result, 'JSON:', JSON.stringify(result));
                return result;
            } catch (error) {
                console.error('[evalHyperScript] ERROR:', error.message, error.stack);
                throw error;
            }
        };
        window.getParseErrorFor = function(expr) {
            try {
                hyperfixi.evalHyperScript(expr);
                return null;
            } catch (e) {
                return e.message;
            }
        };

        // Add Chai-style should assertions to all objects
        Object.defineProperty(Object.prototype, 'should', {
            get: function() {
                const self = this;

                // Helper for deep equality check
                function deepEqual(a, b) {
                    if (a === b) return true;
                    if (a == null || b == null) return a === b;
                    if (typeof a !== typeof b) return false;
                    if (Array.isArray(a) && Array.isArray(b)) {
                        if (a.length !== b.length) return false;
                        return a.every((val, i) => deepEqual(val, b[i]));
                    }
                    if (typeof a === 'object') {
                        const keysA = Object.keys(a);
                        const keysB = Object.keys(b);
                        if (keysA.length !== keysB.length) return false;
                        return keysA.every(key => deepEqual(a[key], b[key]));
                    }
                    return false;
                }

                return {
                    equal: function(expected) {
                        // Convert String objects to primitives for comparison
                        const actualValue = (self != null && self.constructor === String) ? self.valueOf() : self;
                        const expectedValue = (expected != null && expected.constructor === String) ? expected.valueOf() : expected;

                        // Use loose equality for numbers (handles 10 === 10.0)
                        if (typeof actualValue === 'number' && typeof expectedValue === 'number') {
                            if (actualValue !== expectedValue) {
                                throw new Error(`Expected ${JSON.stringify(expectedValue)}, got ${JSON.stringify(actualValue)}`);
                            }
                        } else if (actualValue !== expectedValue) {
                            throw new Error(`Expected ${JSON.stringify(expectedValue)}, got ${JSON.stringify(actualValue)}`);
                        }
                        return this;
                    },
                    deep: {
                        equal: function(expected) {
                            if (!deepEqual(self, expected)) {
                                throw new Error(`Expected deep equal ${JSON.stringify(expected)}, got ${JSON.stringify(self)}`);
                            }
                            return this;
                        }
                    },
                    be: {
                        get a() {
                            return function(type) {
                                const actualType = Object.prototype.toString.call(self).slice(8, -1);
                                if (actualType !== type) {
                                    throw new Error(`Expected type ${type}, got ${actualType}`);
                                }
                                return this;
                            };
                        },
                        true: (function() {
                            if (self !== true) {
                                throw new Error(`Expected true, got ${self}`);
                            }
                        })(),
                        false: (function() {
                            if (self !== false) {
                                throw new Error(`Expected false, got ${self}`);
                            }
                        })()
                    }
                };
            },
            configurable: true,
            enumerable: false
        });
        
        // Clear work area helper
        window.clearWorkArea = function() {
            document.getElementById('work-area').innerHTML = '';
        };

        // Get work area helper (matches official util.js)
        window.getWorkArea = function() {
            return document.getElementById('work-area');
        };

        // byId helper (matches official util.js)
        window.byId = function(id) {
            return document.getElementById(id);
        };

        // Promise helpers for async tests (matches official util.js)
        window.promiseAnIntIn = function(millis) {
            return new Promise(function(resolve) {
                setTimeout(function() {
                    console.log('promiseAnIntIn resolving to 42');
                    resolve(42);
                }, millis);
            });
        };

        window.promiseValueBackIn = function(value, millis) {
            return new Promise(function(resolve) {
                setTimeout(function() {
                    console.log('promiseValueBackIn resolving to', value);
                    resolve(value);
                }, millis);
            });
        };

        // startsWith assertion helper (matches official util.js)
        window.startsWith = function(str, expected) {
            if (str === null || str === undefined) {
                throw new Error('Expected string to not be null');
            }
            if (str.indexOf(expected) !== 0) {
                throw new Error("Expected string:\n\n'" + str + "'\n\nto start with:\n\n" + expected);
            }
        };

        // Chai-style assert object for compatibility
        window.assert = {
            isNotNull: function(value) {
                if (value === null || value === undefined) {
                    throw new Error('Expected value to not be null');
                }
            },
            equal: function(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(message || ('Expected ' + expected + ', got ' + actual));
                }
            },
            isTrue: function(value) {
                if (value !== true) {
                    throw new Error('Expected true, got ' + value);
                }
            },
            isFalse: function(value) {
                if (value !== false) {
                    throw new Error('Expected false, got ' + value);
                }
            }
        };

        // Make function for creating DOM elements with hyperscript behavior
        window.make = function(htmlString) {
            try {
                console.log('[make] Creating element from:', htmlString);

                // Create a temporary container to parse the HTML
                const container = document.createElement('div');
                container.innerHTML = htmlString;

                // Get the first child element
                const element = container.firstElementChild;
                if (!element) {
                    throw new Error('Invalid HTML string');
                }

                console.log('[make] Created element:', element, 'className:', element.className);

                // Add element to work area so it can be queried
                const workArea = document.getElementById('work-area');
                if (workArea) {
                    workArea.appendChild(element);
                    console.log('[make] Added to work area, workArea children:', workArea.children.length);
                } else {
                    console.warn('[make] Work area not found!');
                }

                // Check for hyperscript behavior attribute
                const hyperschriptBehavior = element.getAttribute('_');
                if (hyperschriptBehavior) {
                    // Use our proper hyperscript API instead of custom implementation
                    window.initHyperscriptBehaviorProper(element, hyperschriptBehavior);
                }

                console.log('[make] Returning element:', element);
                return element;
            } catch (error) {
                console.error('make() error:', error.message);
                throw error;
            }
        };
        
        // Proper hyperscript behavior initialization using our API
        window.initHyperscriptBehaviorProper = function(element, behavior) {
            try {
                console.log('Initializing behavior:', behavior, 'on element:', element);
                
                // For event handlers (on syntax), parse and bind them directly
                if (behavior.trim().startsWith('on ')) {
                    const match = behavior.match(/^on\s+(\w+)\s+(.+)$/);
                    if (match) {
                        const [, eventType, commandCode] = match;
                        console.log('Setting up event:', eventType, 'command:', commandCode);
                        
                        if (commandCode) {
                            element.addEventListener(eventType, async (event) => {
                                try {
                                    console.log('Event triggered:', eventType, 'executing:', commandCode);
                                    
                                    // Create proper execution context
                                    const context = hyperfixi.createContext(element);
                                    
                                    // Execute the command using evalHyperScript which we know works
                                    const result = await hyperfixi.evalHyperScript(commandCode, context);
                                    console.log('Command executed, result:', result);
                                } catch (error) {
                                    console.error('Hyperscript execution error:', error);
                                }
                            });
                            console.log('Event listener added for:', eventType);
                        }
                    }
                } else {
                    // For other syntax, try to execute immediately
                    console.log('Non-event behavior, attempting immediate execution');
                    const context = hyperfixi.createContext(element);
                    hyperfixi.evalHyperScript(behavior, context);
                }
            } catch (error) {
                console.error('Error setting up hyperscript behavior:', error);
            }
        };
        
        // Initialize hyperscript behavior on an element
        window.initHyperscriptBehavior = function(element, behavior) {
            // Parse the behavior string to extract event handlers
            // Format: "on <event> <command>"
            const eventHandlers = window.parseHyperscriptBehavior(behavior);
            
            for (const handler of eventHandlers) {
                element.addEventListener(handler.event, function(evt) {
                    try {
                        // Temporarily add element to DOM for selector resolution
                        const wasInDOM = document.body.contains(element);
                        if (!wasInDOM) {
                            document.body.appendChild(element);
                        }
                        
                        // Set up context with proper element binding
                        const context = {
                            me: element,
                            you: null, 
                            it: evt,
                            result: null,
                            locals: new Map(),
                            globals: new Map()
                        };
                        
                        // Execute hyperscript command synchronously for simple commands
                        try {
                            // For simple commands, try synchronous execution
                            window.executeHyperscriptSync(handler.command, context);
                        } catch (error) {
                            console.error('Hyperscript behavior error:', error.message);
                        } finally {
                            // Remove from DOM if we added it temporarily
                            if (!wasInDOM && document.body.contains(element)) {
                                document.body.removeChild(element);
                            }
                        }
                    } catch (error) {
                        console.error('Hyperscript behavior setup error:', error.message);
                    }
                });
            }
        };
        
        // Parse hyperscript behavior string into event handlers
        window.parseHyperscriptBehavior = function(behavior) {
            const handlers = [];
            
            // Handle single event handler case (most common)
            // Pattern: "on <event> <command>"
            const singleMatch = behavior.match(/^on\s+(\w+)\s+(.+)$/);
            if (singleMatch) {
                handlers.push({
                    event: singleMatch[1],
                    command: singleMatch[2].trim()
                });
                return handlers;
            }
            
            // Handle multiple event handlers (fallback for complex cases)
            const matches = behavior.match(/on\s+(\w+)\s+(.+?)(?=\s+on\s+\w+|$)/g);
            
            if (matches) {
                for (const match of matches) {
                    const parts = match.match(/on\s+(\w+)\s+(.+)/);
                    if (parts) {
                        handlers.push({
                            event: parts[1],
                            command: parts[2].trim()
                        });
                    }
                }
            }
            
            return handlers;
        };
        
        // Execute hyperscript commands synchronously for simple cases
        window.executeHyperscriptSync = function(command, context) {
            // Handle simple PUT commands synchronously
            if (command.match(/^put\s+.+\s+into\s+.+$/)) {
                window.executePutCommand(command, context);
                return;
            }
            
            // Handle simple SET commands synchronously
            if (command.match(/^set\s+.+\s+to\s+.+$/)) {
                window.executeSetCommand(command, context);
                return;
            }
            
            // For other commands, fall back to async
            throw new Error('Command requires async execution');
        };
        
        // Synchronous PUT command execution
        window.executePutCommand = function(command, context) {
            const match = command.match(/^put\s+(.+)\s+into\s+(.+)$/);
            if (!match) return;
            
            const [, contentExpr, targetExpr] = match;
            
            // Evaluate content (simple cases)
            let content = window.evaluateSimpleExpression(contentExpr, context);
            
            // Handle target resolution
            if (targetExpr.includes('.innerHTML')) {
                const elementSelector = targetExpr.replace('.innerHTML', '');
                const element = window.resolveElementSimple(elementSelector, context);
                if (element) {
                    element.innerHTML = content;
                }
            } else {
                const element = window.resolveElementSimple(targetExpr, context);
                if (element) {
                    element.textContent = content;
                }
            }
        };
        
        // Synchronous SET command execution
        window.executeSetCommand = function(command, context) {
            const match = command.match(/^set\s+(.+)\s+to\s+(.+)$/);
            if (!match) return;
            
            const [, target, valueExpr] = match;
            
            // Handle "my property" syntax
            if (target.startsWith('my ')) {
                const property = target.replace('my ', '');
                const value = window.evaluateSimpleExpression(valueExpr, context);
                
                if (property === 'innerHTML' && context.me) {
                    context.me.innerHTML = value;
                } else if (property === 'textContent' && context.me) {
                    context.me.textContent = value;
                }
            }
        };
        
        // Simple expression evaluation for synchronous execution
        window.evaluateSimpleExpression = function(expr, context) {
            // Handle string literals
            if (expr.startsWith('"') && expr.endsWith('"')) {
                return expr.slice(1, -1);  // Remove quotes
            }
            if (expr.startsWith("'") && expr.endsWith("'")) {
                return expr.slice(1, -1);  // Remove quotes
            }
            
            // Handle numbers
            const num = parseFloat(expr);
            if (!isNaN(num)) {
                return num;
            }
            
            // Handle simple variables (fallback)
            return expr;
        };
        
        // Simple element resolution for synchronous execution
        window.resolveElementSimple = function(selector, context) {
            // Handle 'me' reference
            if (selector === 'me') {
                return context.me;
            }
            
            // Handle CSS selectors
            if (selector.startsWith('#') || selector.startsWith('.')) {
                return document.querySelector(selector);
            }
            
            return null;
        };
        
        // Test command execution helper
        window.testCommandExecution = async function(command, context = {}) {
            try {
                // Set up context variables globally for the command to access
                if (context) {
                    Object.assign(window, context);
                }
                
                // Pass context with locals for variable resolution
                const hyperscriptContext = {
                    locals: context,
                    globals: context
                };
                
                // For PUT commands with variables, test variable resolution first
                if (command.startsWith('put ') && Object.keys(context).length > 0) {
                    const varName = Object.keys(context)[0];
                    try {
                        const varTest = await hyperfixi.evalHyperScript(varName, hyperscriptContext);
                        if (varTest === null || varTest === undefined) {
                            throw new Error(`Variable ${varName} resolved to ${varTest}`);
                        }
                    } catch (err) {
                        throw new Error(`Variable resolution failed: ${err.message}`);
                    }
                }
                
                await hyperfixi.evalHyperScript(command, hyperscriptContext);
                
                // Return context variables that may have been set
                const result = {};
                // Copy any global variables that may have been set
                if (window.x !== undefined) result.x = window.x;
                if (window.message !== undefined) result.message = window.message;
                if (window.result !== undefined) result.result = window.result;
                if (window.myVar !== undefined) result.myVar = window.myVar;
                if (window.myValue !== undefined) result.myValue = window.myValue;
                
                return { success: true, context: result };
            } catch (error) {
                return { success: false, error: error.message };
            }
        };
        
        // Helper for context conversion - _hyperscript uses different context format
        window.testExpressionWithContext = async function(expression, context = {}) {
            try {
                // Convert our context format to _hyperscript format if needed
                let hyperschriptContext = context;
                if (context.locals) {
                    // _hyperscript expects variables in the root context
                    hyperschriptContext = { ...context, ...context.locals };
                }
                if (context.me) {
                    hyperschriptContext.me = context.me;
                }
                if (context.you) {
                    hyperschriptContext.you = context.you;
                }
                if (context.result) {
                    hyperschriptContext.it = context.result;
                }
                
                const original = _hyperscript.evaluate(expression, hyperschriptContext);
                const ours = await hyperfixi.evalHyperScript(expression, context);
                return { expression, original, ours, match: original === ours };
            } catch (error) {
                return { expression, error: error.message, match: false };
            }
        };
    </script>
</body>
</html>