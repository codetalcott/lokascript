/**
 * Build-time Plugin Optimization
 * Generates optimized bundles based on usage analysis
 */

import { PluginAnalyzer } from './analyzer';
import * as fs from 'fs/promises';
import * as path from 'path';
import type { Plugin } from '../types';

export interface BuildConfig {
  // Source directories to analyze
  srcDirs: string[];
  
  // Output directory for generated bundles
  outDir: string;
  
  // Available plugins
  plugins: Plugin[];
  
  // Bundle configurations
  bundles: {
    name: string;
    include?: string[];  // Specific plugins to include
    exclude?: string[];  // Plugins to exclude
    analyze?: boolean;   // Auto-detect from source
  }[];
}

export class PluginBundleBuilder {
  private analyzer: PluginAnalyzer;
  
  constructor(private config: BuildConfig) {
    this.analyzer = new PluginAnalyzer(config.plugins);
  }

  /**
   * Build all configured bundles
   */
  async build(): Promise<void> {
    console.log('ðŸ”¨ Building optimized plugin bundles...');
    
    // Ensure output directory exists
    await fs.mkdir(this.config.outDir, { recursive: true });

    // Analyze source if needed
    const sourceAnalysis = await this.analyzeSource();
    
    // Build each bundle
    for (const bundleConfig of this.config.bundles) {
      await this.buildBundle(bundleConfig, sourceAnalysis);
    }

    // Generate bundle manifest
    await this.generateManifest();
    
    console.log('âœ… Bundle generation complete!');
  }

  /**
   * Analyze source code to determine plugin usage
   */
  private async analyzeSource() {
    console.log('ðŸ“Š Analyzing source code...');
    
    const results = {
      requiredPlugins: new Set<string>(),
      attributePatterns: new Map<string, string[]>(),
      usageStats: new Map<string, number>()
    };

    for (const dir of this.config.srcDirs) {
      const files = await this.getSourceFiles(dir);
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf-8');
        const analysis = this.analyzer.analyzeHTML(content);
        
        // Merge results
        analysis.requiredPlugins.forEach(p => results.requiredPlugins.add(p));
        analysis.usageStats.forEach((count, plugin) => {
          results.usageStats.set(plugin, 
            (results.usageStats.get(plugin) || 0) + count
          );
        });
      }
    }

    console.log(`  Found ${results.requiredPlugins.size} required plugins`);
    return results;
  }

  /**
   * Build a specific bundle
   */
  private async buildBundle(
    bundleConfig: any,
    sourceAnalysis: any
  ): Promise<void> {
    console.log(`ðŸ“¦ Building bundle: ${bundleConfig.name}`);
    
    // Determine which plugins to include
    let plugins: Set<string>;
    
    if (bundleConfig.analyze) {
      plugins = new Set(sourceAnalysis.requiredPlugins);
    } else {
      plugins = new Set(bundleConfig.include || []);
    }
    
    // Apply exclusions
    if (bundleConfig.exclude) {
      bundleConfig.exclude.forEach((p: string) => plugins.delete(p));
    }

    // Generate bundle code
    const code = this.generateBundleCode(bundleConfig.name, plugins, sourceAnalysis.usageStats);
    
    // Write bundle file
    const outputPath = path.join(this.config.outDir, `${bundleConfig.name}.bundle.js`);
    await fs.writeFile(outputPath, code);
    
    // Generate TypeScript definitions
    const dts = this.generateTypeDefinitions(bundleConfig.name, plugins);
    await fs.writeFile(outputPath.replace('.js', '.d.ts'), dts);
    
    console.log(`  âœ“ Generated ${bundleConfig.name} (${plugins.size} plugins)`);
  }

  /**
   * Generate bundle code
   */
  private generateBundleCode(
    name: string,
    plugins: Set<string>,
    usageStats: Map<string, number>
  ): string {
    const sortedPlugins = Array.from(plugins).sort((a, b) => 
      (usageStats.get(b) || 0) - (usageStats.get(a) || 0)
    );

    return `/**
 * ${name} Plugin Bundle
 * Auto-generated by Hyperfixi Plugin System
 * Generated: ${new Date().toISOString()}
 * Plugins: ${sortedPlugins.join(', ')}
 */

import { optimizedRegistry } from '@hyperfixi/plugin-system';
${sortedPlugins.map(p => 
  `import { ${this.getPluginImportName(p)} } from '@hyperfixi/plugins/${p}';`
).join('\n')}

// Load plugins in order of usage frequency for optimal performance
optimizedRegistry.load(
${sortedPlugins.map(p => `  ${this.getPluginImportName(p)}`).join(',\n')}
);

// Export registry for additional runtime configuration
export { optimizedRegistry as pluginRegistry };

// Auto-initialize if in browser environment
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      optimizedRegistry.apply();
    });
  } else {
    // DOM already loaded
    optimizedRegistry.apply();
  }
}
`;
  }

  /**
   * Generate TypeScript definitions
   */
  private generateTypeDefinitions(name: string, plugins: Set<string>): string {
    return `/**
 * TypeScript definitions for ${name} bundle
 */

import type { OptimizedPluginRegistry } from '@hyperfixi/plugin-system';

export declare const pluginRegistry: OptimizedPluginRegistry;

// Available plugins in this bundle
export type BundledPlugins = ${Array.from(plugins).map(p => `'${p}'`).join(' | ')};
`;
  }

  /**
   * Generate manifest file
   */
  private async generateManifest(): Promise<void> {
    const manifest = {
      generated: new Date().toISOString(),
      bundles: this.config.bundles.map(b => ({
        name: b.name,
        plugins: b.include || [],
        size: 0 // Would calculate actual size
      }))
    };

    await fs.writeFile(
      path.join(this.config.outDir, 'manifest.json'),
      JSON.stringify(manifest, null, 2)
    );
  }

  /**
   * Get all source files recursively
   */
  private async getSourceFiles(dir: string): Promise<string[]> {
    const files: string[] = [];
    const entries = await fs.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        files.push(...await this.getSourceFiles(fullPath));
      } else if (entry.isFile() && this.isSourceFile(entry.name)) {
        files.push(fullPath);
      }
    }
    
    return files;
  }

  private isSourceFile(filename: string): boolean {
    return /\.(html|htm|tsx?|jsx?)$/.test(filename);
  }

  private getPluginImportName(pluginName: string): string {
    return pluginName
      .split('-')
      .map((p, i) => i === 0 ? p : p[0].toUpperCase() + p.slice(1))
      .join('') + 'Plugin';
  }
}

/**
 * CLI interface for bundle building
 */
export async function buildBundles(configPath: string) {
  const config = await import(configPath);
  const builder = new PluginBundleBuilder(config.default || config);
  await builder.build();
}
