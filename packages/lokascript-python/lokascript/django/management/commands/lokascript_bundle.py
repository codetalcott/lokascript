"""
Django management command to scan templates and generate bundle configuration.

Usage:
    python manage.py hyperfixi_bundle
    python manage.py hyperfixi_bundle --output bundle-config.json
    python manage.py hyperfixi_bundle --format summary
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.template import engines

from lokascript.scanner import (
    Scanner,
    VALID_COMMANDS,
    VALID_BLOCKS,
    SUPPORTED_LANGUAGES,
    get_optimal_region,
)
from lokascript.aggregator import Aggregator

if TYPE_CHECKING:
    from argparse import ArgumentParser


class Command(BaseCommand):
    """Scan Django templates for hyperscript usage and generate bundle config."""

    help = "Scan templates for hyperscript and generate minimal bundle configuration"

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--output",
            "-o",
            type=str,
            help="Output file path (default: stdout)",
        )
        parser.add_argument(
            "--format",
            "-f",
            choices=["json", "js-config", "summary"],
            default="json",
            help="Output format (default: json)",
        )
        parser.add_argument(
            "--name",
            type=str,
            default="DjangoAutoGenerated",
            help="Bundle name for generated config",
        )
        parser.add_argument(
            "--extra-commands",
            type=str,
            help="Comma-separated list of extra commands to always include",
        )
        parser.add_argument(
            "--extra-blocks",
            type=str,
            help="Comma-separated list of extra blocks to always include",
        )
        parser.add_argument(
            "--htmx",
            action="store_true",
            help="Enable HTMX integration in generated bundle",
        )
        parser.add_argument(
            "--positional",
            action="store_true",
            help="Always include positional expressions",
        )
        parser.add_argument(
            "--semantic",
            type=str,
            choices=["false", "true", "en", "auto"],
            default="false",
            help="Enable semantic parser (false, true, en, or auto)",
        )
        parser.add_argument(
            "--languages",
            type=str,
            help="Comma-separated list of languages to support (e.g., en,es,ja)",
        )
        parser.add_argument(
            "--region",
            type=str,
            choices=["western", "east-asian", "priority", "all"],
            help="Force a specific regional bundle",
        )
        parser.add_argument(
            "--grammar",
            action="store_true",
            help="Enable grammar transformation for non-SVO languages",
        )
        parser.add_argument(
            "--extra-languages",
            type=str,
            help="Comma-separated list of languages to always include",
        )
        parser.add_argument(
            "--verbose",
            "-v",
            action="count",
            default=0,
            help="Increase verbosity",
        )
        parser.add_argument(
            "paths",
            nargs="*",
            type=str,
            help="Specific directories to scan (default: all template dirs)",
        )

    def handle(self, *args, **options) -> None:
        verbose = options["verbose"]

        self.stdout.write("Scanning templates for hyperscript usage...\n")

        # Get template directories
        template_dirs = self._get_template_dirs(options["paths"])

        if not template_dirs:
            raise CommandError("No template directories found")

        if verbose:
            self.stdout.write(f"Scanning directories: {template_dirs}\n")

        # Create scanner and aggregator
        scanner = Scanner(debug=verbose > 1)
        aggregator = Aggregator()

        # Scan all directories
        for dir_path in template_dirs:
            usage_map = scanner.scan_directory(dir_path)
            for file_path, usage in usage_map.items():
                aggregator.add(file_path, usage)

        if not aggregator.has_usage():
            self.stdout.write(self.style.WARNING("No hyperscript usage detected\n"))
            return

        # Get aggregated usage
        usage = aggregator.get_usage()

        # Apply extra commands/blocks from CLI
        extra_commands: set[str] = set()
        extra_blocks: set[str] = set()

        if options["extra_commands"]:
            extra_commands = {
                c.strip().lower() for c in options["extra_commands"].split(",")
            }

        if options["extra_blocks"]:
            extra_blocks = {b.strip().lower() for b in options["extra_blocks"].split(",")}

        # Apply settings from Django HYPERFIXI config
        hyperfixi_settings = getattr(settings, "HYPERFIXI", {})
        if hyperfixi_settings.get("EXTRA_COMMANDS"):
            extra_commands.update(
                c.lower() for c in hyperfixi_settings["EXTRA_COMMANDS"]
            )
        if hyperfixi_settings.get("EXTRA_BLOCKS"):
            extra_blocks.update(b.lower() for b in hyperfixi_settings["EXTRA_BLOCKS"])

        # Merge with detected usage
        all_commands = usage.commands | extra_commands
        all_blocks = usage.blocks | extra_blocks
        positional = (
            usage.positional
            or options["positional"]
            or hyperfixi_settings.get("POSITIONAL", False)
        )
        htmx = options["htmx"] or hyperfixi_settings.get("HTMX", False)

        # Validate commands and blocks
        unknown_commands = all_commands - VALID_COMMANDS
        if unknown_commands and verbose:
            self.stdout.write(
                self.style.WARNING(
                    f"Unknown commands (will be skipped): {sorted(unknown_commands)}\n"
                )
            )

        unknown_blocks = all_blocks - VALID_BLOCKS
        if unknown_blocks and verbose:
            self.stdout.write(
                self.style.WARNING(
                    f"Unknown blocks (will be skipped): {sorted(unknown_blocks)}\n"
                )
            )

        # Filter to valid only
        valid_commands = sorted(all_commands & VALID_COMMANDS)
        valid_blocks = sorted(all_blocks & VALID_BLOCKS)

        # Process multilingual options
        semantic = options["semantic"]
        grammar = options["grammar"] or hyperfixi_settings.get("GRAMMAR", False)

        # Get languages from CLI, settings, or auto-detect
        all_languages: set[str] = set()

        if options["languages"]:
            all_languages.update(
                lang.strip().lower() for lang in options["languages"].split(",")
            )
        if hyperfixi_settings.get("LANGUAGES"):
            all_languages.update(
                lang.lower() for lang in hyperfixi_settings["LANGUAGES"]
            )
        if options["extra_languages"]:
            all_languages.update(
                lang.strip().lower() for lang in options["extra_languages"].split(",")
            )
        if hyperfixi_settings.get("EXTRA_LANGUAGES"):
            all_languages.update(
                lang.lower() for lang in hyperfixi_settings["EXTRA_LANGUAGES"]
            )

        # Apply settings semantic option
        if hyperfixi_settings.get("SEMANTIC"):
            settings_semantic = hyperfixi_settings["SEMANTIC"]
            if settings_semantic is True or settings_semantic == "true":
                semantic = "true"
            elif settings_semantic == "en":
                semantic = "en"
            elif settings_semantic == "auto":
                semantic = "auto"

        # Auto-detect languages if semantic is 'auto' or 'true'
        detected_languages = usage.detected_languages
        if semantic in ("auto", "true"):
            all_languages.update(detected_languages)
            if verbose and detected_languages:
                self.stdout.write(
                    f"Detected languages: {sorted(detected_languages)}\n"
                )

        # Determine region (explicit or optimal)
        region = options["region"] or hyperfixi_settings.get("REGION")
        if not region and all_languages:
            region = get_optimal_region(all_languages)
            if verbose and region:
                self.stdout.write(f"Selected optimal region: {region}\n")

        # Validate languages
        valid_languages = sorted(
            lang for lang in all_languages if lang in SUPPORTED_LANGUAGES
        )
        unknown_languages = all_languages - set(SUPPORTED_LANGUAGES)
        if unknown_languages and verbose:
            self.stdout.write(
                self.style.WARNING(
                    f"Unknown languages (will be skipped): {sorted(unknown_languages)}\n"
                )
            )

        # Determine if semantic should be enabled
        semantic_enabled = semantic in ("true", "en", "auto") or bool(valid_languages)

        # Generate output
        output_format = options["format"]

        if output_format == "summary":
            output = self._format_summary(
                valid_commands,
                valid_blocks,
                positional,
                htmx,
                len(usage.file_usage),
                semantic_enabled,
                valid_languages,
                region,
                grammar,
            )
        elif output_format == "js-config":
            output = self._format_js_config(
                options["name"],
                valid_commands,
                valid_blocks,
                positional,
                htmx,
                semantic_enabled,
                valid_languages,
                region,
                grammar,
            )
        else:  # json
            output = self._format_json(
                options["name"],
                valid_commands,
                valid_blocks,
                positional,
                htmx,
                list(usage.file_usage.keys()),
                semantic_enabled,
                valid_languages,
                region,
                grammar,
            )

        # Write output
        if options["output"]:
            output_path = Path(options["output"])
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(output)
            self.stdout.write(self.style.SUCCESS(f"Written to {output_path}\n"))
        else:
            self.stdout.write(output)

        # Summary
        summary_parts = [
            f"\nDetected: {len(valid_commands)} commands, {len(valid_blocks)} blocks",
            f"positional={positional}",
        ]
        if semantic_enabled:
            summary_parts.append(f"semantic=true")
            if valid_languages:
                summary_parts.append(f"languages={valid_languages}")
            if region:
                summary_parts.append(f"region={region}")
            if grammar:
                summary_parts.append("grammar=true")
        summary_parts.append(f"across {len(usage.file_usage)} files")

        self.stdout.write(
            self.style.SUCCESS(", ".join(summary_parts) + "\n")
        )

    def _get_template_dirs(self, paths: list[str]) -> list[Path]:
        """Get template directories to scan."""
        if paths:
            return [Path(p) for p in paths if Path(p).exists()]

        dirs: list[Path] = []

        # Get from Django template engines
        for engine in engines.all():
            for template_dir in engine.dirs:
                dirs.append(Path(template_dir))

            # Also check app template directories
            if hasattr(engine, "engine") and hasattr(engine.engine, "dirs"):
                for template_dir in engine.engine.dirs:
                    dirs.append(Path(template_dir))

        # Check TEMPLATES setting directly
        for template_config in settings.TEMPLATES:
            for dir_path in template_config.get("DIRS", []):
                dirs.append(Path(dir_path))

        return [d for d in set(dirs) if d.exists()]

    def _format_summary(
        self,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
        file_count: int,
        semantic: bool = False,
        languages: list[str] | None = None,
        region: str | None = None,
        grammar: bool = False,
    ) -> str:
        """Format as human-readable summary."""
        lines = [
            "",
            "HyperFixi Bundle Summary",
            "=" * 40,
            f"Commands ({len(commands)}): {', '.join(commands) if commands else 'none'}",
            f"Blocks ({len(blocks)}): {', '.join(blocks) if blocks else 'none'}",
            f"Positional: {positional}",
            f"HTMX: {htmx}",
        ]

        if semantic:
            lines.append(f"Semantic: {semantic}")
            if languages:
                lines.append(f"Languages: {', '.join(languages)}")
            if region:
                lines.append(f"Region: {region}")
            if grammar:
                lines.append(f"Grammar: {grammar}")

        lines.extend([
            f"Files scanned: {file_count}",
            "",
            "Recommended bundle command:",
        ])

        # Build command
        cmd_parts = ["  npm run generate:bundle --"]
        if commands:
            cmd_parts.append(f"--commands {','.join(commands)}")
        if blocks:
            cmd_parts.append(f"--blocks {','.join(blocks)}")
        if positional:
            cmd_parts.append("--positional")
        if htmx:
            cmd_parts.append("--htmx")
        if semantic:
            cmd_parts.append("--semantic")
        if languages:
            cmd_parts.append(f"--languages {','.join(languages)}")
        if region:
            cmd_parts.append(f"--region {region}")
        if grammar:
            cmd_parts.append("--grammar")

        lines.append(" ".join(cmd_parts))
        lines.append("")

        return "\n".join(lines)

    def _format_js_config(
        self,
        name: str,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
        semantic: bool = False,
        languages: list[str] | None = None,
        region: str | None = None,
        grammar: bool = False,
    ) -> str:
        """Format as JavaScript config object."""
        config_parts = [
            f'  name: "{name}",',
            f"  commands: {json.dumps(commands)},",
        ]
        if blocks:
            config_parts.append(f"  blocks: {json.dumps(blocks)},")
        if positional:
            config_parts.append("  positionalExpressions: true,")
        if htmx:
            config_parts.append("  htmxIntegration: true,")
        if semantic:
            config_parts.append("  semantic: true,")
        if languages:
            config_parts.append(f"  languages: {json.dumps(languages)},")
        if region:
            config_parts.append(f'  region: "{region}",')
        if grammar:
            config_parts.append("  grammar: true,")
        config_parts.append('  globalName: "lokascript"')

        return (
            "// Auto-generated by: python manage.py hyperfixi_bundle\n"
            + "const bundleConfig = {\n"
            + "\n".join(config_parts)
            + "\n};\n"
        )

    def _format_json(
        self,
        name: str,
        commands: list[str],
        blocks: list[str],
        positional: bool,
        htmx: bool,
        files: list[str],
        semantic: bool = False,
        languages: list[str] | None = None,
        region: str | None = None,
        grammar: bool = False,
    ) -> str:
        """Format as JSON config file."""
        config: dict = {
            "name": name,
            "commands": commands,
            "output": f"dist/hyperfixi-{name.lower()}.js",
            "globalName": "lokascript",
        }
        if blocks:
            config["blocks"] = blocks
        if positional:
            config["positionalExpressions"] = True
        if htmx:
            config["htmxIntegration"] = True
        if semantic:
            config["semantic"] = True
        if languages:
            config["languages"] = languages
        if region:
            config["region"] = region
        if grammar:
            config["grammar"] = True

        # Include file list for reference (as metadata)
        config["_meta"] = {
            "generated_by": "lokascript_bundle",
            "file_count": len(files),
            "files": sorted(files)[:20],  # Limit to first 20
        }

        return json.dumps(config, indent=2) + "\n"
