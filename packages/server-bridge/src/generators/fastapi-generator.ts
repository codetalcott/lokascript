import type { RouteDescriptor, GeneratorOptions, GenerateResult, GeneratedFile } from '../types.js';
import type { RouteGenerator } from './types.js';
import { groupRoutesByPrefix } from './template-helpers.js';

const PY_ROUTE_MARKER = '# @serverbridge-route:';
const PY_USER_START = '# @serverbridge-user-start';
const PY_USER_END = '# @serverbridge-user-end';

export class FastAPIGenerator implements RouteGenerator {
  readonly framework = 'fastapi';

  generate(routes: RouteDescriptor[], options: GeneratorOptions): GenerateResult {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];

    if (routes.length === 0) {
      warnings.push('No routes to generate');
      return { files, preserved: [], warnings };
    }

    const groups = groupRoutesByPrefix(routes);

    for (const [groupKey, groupRoutes] of groups) {
      const content = this.generateRouterFile(groupRoutes, groupKey);
      const pyFilename = groupKey.replace(/-/g, '_');
      files.push({ path: `routers/${pyFilename}.py`, content, isNew: true });
    }

    // Main app file that includes all routers
    const mainContent = this.generateMain(groups);
    files.push({ path: 'main.py', content: mainContent, isNew: true });

    // Pydantic models file if any routes have request bodies
    const allRoutes = [...groups.values()].flat();
    const routesWithBodies = allRoutes.filter(
      r => r.requestBody && r.requestBody.length > 0 && ['POST', 'PUT', 'PATCH'].includes(r.method)
    );
    if (routesWithBodies.length > 0) {
      const models = this.generateModels(routesWithBodies);
      files.push({ path: 'models.py', content: models, isNew: true });
    }

    return { files, preserved: [], warnings };
  }

  private generateRouterFile(routes: RouteDescriptor[], groupKey: string): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT scaffold markers`);
    lines.push(`from fastapi import APIRouter`);

    // Check if we need models import
    const routesWithBodies = routes.filter(
      r => r.requestBody && r.requestBody.length > 0 && ['POST', 'PUT', 'PATCH'].includes(r.method)
    );
    if (routesWithBodies.length > 0) {
      const modelNames = routesWithBodies.map(r => modelName(r.handlerName));
      lines.push(`from ..models import ${modelNames.join(', ')}`);
    }

    // Check response types needed
    const needsHtml = routes.some(r => r.responseFormat === 'html');
    const needsPlaintext = routes.some(r => r.responseFormat === 'text');
    if (needsHtml || needsPlaintext) {
      lines.push(`from fastapi.responses import HTMLResponse, PlainTextResponse`);
    }

    lines.push('');
    lines.push(`router = APIRouter()`);
    lines.push('');

    for (const route of routes) {
      lines.push('');
      lines.push(`${PY_ROUTE_MARKER} ${route.method} ${route.path}`);
      lines.push(this.generateEndpoint(route));
    }

    lines.push('');
    return lines.join('\n');
  }

  private generateEndpoint(route: RouteDescriptor): string {
    const lines: string[] = [];
    const method = route.method.toLowerCase();
    const funcName = toSnakeCase(route.handlerName);
    const fastapiPath = toFastAPIPath(route.path);

    // Response class for non-JSON
    const extraArgs: string[] = [];
    if (route.responseFormat === 'html') {
      extraArgs.push('response_class=HTMLResponse');
    } else if (route.responseFormat === 'text') {
      extraArgs.push('response_class=PlainTextResponse');
    }

    const argsStr = extraArgs.length > 0 ? `, ${extraArgs.join(', ')}` : '';
    lines.push(`@router.${method}('${fastapiPath}'${argsStr})`);

    // Function signature with typed params
    const params: string[] = [];
    for (const param of route.pathParams) {
      params.push(`${param}: str`);
    }
    if (
      route.requestBody &&
      route.requestBody.length > 0 &&
      ['POST', 'PUT', 'PATCH'].includes(route.method)
    ) {
      params.push(`body: ${modelName(route.handlerName)}`);
    }

    lines.push(`async def ${funcName}(${params.join(', ')}):`);
    lines.push(`    ${PY_USER_START}`);

    // TODO block
    lines.push(`    # TODO: Implement ${route.method} ${route.path}`);
    if (route.pathParams.length > 0) {
      lines.push(`    # Path params: ${route.pathParams.join(', ')}`);
    }
    if (route.requestBody && route.requestBody.length > 0) {
      const fields = route.requestBody
        .map(f => `${f.name}: ${pythonType(f.type)}${f.required ? '' : ' (optional)'}`)
        .join(', ');
      lines.push(`    # Expected body: { ${fields} }`);
    }
    for (const note of route.notes) {
      lines.push(`    # Note: ${note}`);
    }

    // Response stub
    if (route.responseFormat === 'json') {
      lines.push(`    return {'message': 'Not implemented'}`);
    } else if (route.responseFormat === 'html') {
      lines.push(`    return '<div>Not implemented</div>'`);
    } else {
      lines.push(`    return 'Not implemented'`);
    }

    lines.push(`    ${PY_USER_END}`);
    return lines.join('\n');
  }

  private generateMain(groups: Map<string, RouteDescriptor[]>): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`from fastapi import FastAPI`);

    for (const groupKey of groups.keys()) {
      const pyName = groupKey.replace(/-/g, '_');
      lines.push(`from .routers.${pyName} import router as ${pyName}_router`);
    }

    lines.push('');
    lines.push('app = FastAPI()');
    lines.push('');

    for (const groupKey of groups.keys()) {
      const pyName = groupKey.replace(/-/g, '_');
      lines.push(`app.include_router(${pyName}_router)`);
    }

    lines.push('');
    return lines.join('\n');
  }

  private generateModels(routes: RouteDescriptor[]): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`from pydantic import BaseModel`);
    lines.push(`from typing import Optional`);
    lines.push('');

    for (const route of routes) {
      if (!route.requestBody || route.requestBody.length === 0) continue;

      lines.push('');
      lines.push(`class ${modelName(route.handlerName)}(BaseModel):`);

      for (const field of route.requestBody) {
        const pyType = pythonType(field.type);
        if (field.required) {
          lines.push(`    ${field.name}: ${pyType}`);
        } else {
          lines.push(`    ${field.name}: Optional[${pyType}] = None`);
        }
      }
    }

    lines.push('');
    return lines.join('\n');
  }
}

/**
 * Convert camelCase handler name to snake_case for Python.
 */
function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '');
}

/**
 * Convert Express-style :param path to FastAPI {param} path.
 * "/api/users/:id" → "/api/users/{id}"
 */
function toFastAPIPath(path: string): string {
  return path.replace(/:(\w+)/g, '{$1}');
}

/**
 * Generate a Pydantic model name from handler name.
 * "postApiUsers" → "PostApiUsersBody"
 */
function modelName(handlerName: string): string {
  return handlerName.charAt(0).toUpperCase() + handlerName.slice(1) + 'Body';
}

/**
 * Map our field types to Python type hints.
 */
function pythonType(type: string): string {
  switch (type) {
    case 'number':
      return 'int';
    case 'boolean':
      return 'bool';
    case 'file':
      return 'bytes';
    default:
      return 'str';
  }
}
