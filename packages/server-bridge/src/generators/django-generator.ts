import type { RouteDescriptor, GeneratorOptions, GenerateResult, GeneratedFile } from '../types.js';
import type { RouteGenerator } from './types.js';
import { groupRoutesByPrefix } from './template-helpers.js';

const PY_ROUTE_MARKER = '# @serverbridge-route:';
const PY_USER_START = '# @serverbridge-user-start';
const PY_USER_END = '# @serverbridge-user-end';

export class DjangoGenerator implements RouteGenerator {
  readonly framework = 'django';

  generate(routes: RouteDescriptor[], options: GeneratorOptions): GenerateResult {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];

    if (routes.length === 0) {
      warnings.push('No routes to generate');
      return { files, preserved: [], warnings };
    }

    const groups = groupRoutesByPrefix(routes);

    // Generate views.py and urls.py per group
    for (const [groupKey, groupRoutes] of groups) {
      const views = this.generateViews(groupRoutes, groupKey);
      files.push({ path: `${groupKey}/views.py`, content: views, isNew: true });

      const urls = this.generateUrls(groupRoutes, groupKey);
      files.push({ path: `${groupKey}/urls.py`, content: urls, isNew: true });

      // Empty __init__.py for Python package
      files.push({ path: `${groupKey}/__init__.py`, content: '', isNew: true });
    }

    // Root urls.py that includes all groups
    const rootUrls = this.generateRootUrls(groups);
    files.push({ path: 'urls.py', content: rootUrls, isNew: true });

    return { files, preserved: [], warnings };
  }

  private generateViews(routes: RouteDescriptor[], groupKey: string): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT scaffold markers`);
    lines.push(`from django.http import JsonResponse, HttpResponse`);

    // Check if any route needs request body parsing
    const needsJson = routes.some(
      r => r.requestBody && r.requestBody.length > 0 && ['POST', 'PUT', 'PATCH'].includes(r.method)
    );
    if (needsJson) {
      lines.push(`import json`);
    }

    // Check if we need decorators
    const hasNonGet = routes.some(r => r.method !== 'GET');
    if (hasNonGet) {
      lines.push(`from django.views.decorators.http import require_http_methods`);
    }

    lines.push('');

    for (const route of routes) {
      lines.push('');
      lines.push(`${PY_ROUTE_MARKER} ${route.method} ${route.path}`);
      lines.push(this.generateView(route));
    }

    lines.push('');
    return lines.join('\n');
  }

  private generateView(route: RouteDescriptor): string {
    const lines: string[] = [];
    const funcName = toSnakeCase(route.handlerName);

    // Method decorator for non-GET routes
    if (route.method !== 'GET') {
      lines.push(`@require_http_methods(["${route.method}"])`);
    }

    // Function signature with path params
    const params = ['request', ...route.pathParams];
    lines.push(`def ${funcName}(${params.join(', ')}):`);
    lines.push(`    ${PY_USER_START}`);

    // TODO block
    lines.push(`    # TODO: Implement ${route.method} ${route.path}`);
    if (route.pathParams.length > 0) {
      lines.push(`    # Path params: ${route.pathParams.join(', ')}`);
    }
    if (route.requestBody && route.requestBody.length > 0) {
      const fields = route.requestBody
        .map(f => `${f.name}: ${pythonType(f.type)}${f.required ? '' : ' (optional)'}`)
        .join(', ');
      lines.push(`    # Expected body: { ${fields} }`);
    }
    for (const note of route.notes) {
      lines.push(`    # Note: ${note}`);
    }

    // Parse body for POST/PUT/PATCH
    if (
      route.requestBody &&
      route.requestBody.length > 0 &&
      ['POST', 'PUT', 'PATCH'].includes(route.method)
    ) {
      lines.push(`    data = json.loads(request.body)`);
      for (const field of route.requestBody) {
        const default_ = field.required ? '' : ', None';
        lines.push(`    ${field.name} = data.get('${field.name}'${default_})`);
      }
    }

    // Response stub
    if (route.responseFormat === 'json') {
      lines.push(`    return JsonResponse({'message': 'Not implemented'})`);
    } else if (route.responseFormat === 'html') {
      lines.push(`    return HttpResponse('<div>Not implemented</div>')`);
    } else {
      lines.push(`    return HttpResponse('Not implemented', content_type='text/plain')`);
    }

    lines.push(`    ${PY_USER_END}`);
    return lines.join('\n');
  }

  private generateUrls(routes: RouteDescriptor[], groupKey: string): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`from django.urls import path`);
    lines.push(`from . import views`);
    lines.push('');
    lines.push('urlpatterns = [');

    for (const route of routes) {
      const djangoPath = toDjangoPath(route.path);
      const funcName = toSnakeCase(route.handlerName);
      lines.push(`    path('${djangoPath}', views.${funcName}, name='${funcName}'),`);
    }

    lines.push(']');
    lines.push('');

    return lines.join('\n');
  }

  private generateRootUrls(groups: Map<string, RouteDescriptor[]>): string {
    const lines: string[] = [];

    lines.push(`# Generated by @hyperfixi/server-bridge — DO NOT EDIT`);
    lines.push(`from django.urls import path, include`);
    lines.push('');
    lines.push('urlpatterns = [');

    for (const groupKey of groups.keys()) {
      lines.push(`    path('', include('${groupKey}.urls')),`);
    }

    lines.push(']');
    lines.push('');

    return lines.join('\n');
  }
}

/**
 * Convert camelCase handler name to snake_case for Python.
 */
function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '');
}

/**
 * Convert Express-style :param path to Django <param> path.
 * "/api/users/:id" → "api/users/<int:id>"
 */
function toDjangoPath(path: string): string {
  return path
    .replace(/^\//, '') // Strip leading slash (Django convention)
    .replace(/:(\w+)/g, '<str:$1>'); // :param → <str:param>
}

/**
 * Map our field types to Python type hints.
 */
function pythonType(type: string): string {
  switch (type) {
    case 'number':
      return 'int';
    case 'boolean':
      return 'bool';
    case 'file':
      return 'UploadedFile';
    default:
      return 'str';
  }
}
