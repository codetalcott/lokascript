<!DOCTYPE html>
<html>
<head>
    <title>Simple HyperFixi Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test { padding: 20px; margin: 10px; border: 2px solid #ccc; }
        .success { border-color: green; background: #f0fff0; }
        .error { border-color: red; background: #fff0f0; }
        button { padding: 10px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Simple HyperFixi Test</h1>
    
    <div class="test">
        <h3>Test 1: Basic Fetch Command</h3>
        <button id="test1" _="on click fetch /api/test">Basic Fetch</button>
        <div id="result1">Click button to test</div>
    </div>
    
    <div class="test">
        <h3>Test 2: Fetch with Replace</h3>
        <button id="test2" _="on click fetch /api/replace and replace #result2">Fetch Replace</button>
        <div id="result2">Original content</div>
    </div>
    
    <div class="test">
        <h3>Test 3: Fetch with Put Into</h3>
        <button id="test3" _="on click fetch /api/content and put into #result3">Fetch Put Into</button>
        <div id="result3">Container: <span>original</span></div>
    </div>
    
    <div class="test">
        <h3>Test 4: Fetch with Append To</h3>
        <button id="test4" _="on click fetch /api/append and append to #result4">Fetch Append</button>
        <div id="result4">Original content</div>
    </div>
    
    <div class="test">
        <h3>Test 5: Fetch with Prepend To</h3>
        <button id="test5" _="on click fetch /api/prepend and prepend to #result5">Fetch Prepend</button>
        <div id="result5">Original content</div>
    </div>
    
    <div class="test">
        <h3>Test 6: Extended Syntax (POST)</h3>
        <button id="test6" _="on click fetch /api/post with method: 'POST', body: 'test data'">POST Request</button>
        <div id="result6">POST result will appear here</div>
    </div>
    
    <div class="test">
        <h3>Test 7: Event Integration</h3>
        <button id="test7" _="on click fetch /api/events and put into #result7 on fx:after add .success to me">
            Test Events
        </button>
        <div id="result7">Events test result</div>
        <div id="event-log">Event log will appear here</div>
    </div>
    
    <div class="test">
        <h3>Console Output</h3>
        <p>Check browser console for detailed logging</p>
    </div>
    
    <!-- Dependencies -->
    <script src="hyperscript/_hyperscript.js"></script>
    <script src="fixi/fixi.js"></script>
    
    <!-- Mock Server -->
    <script>
        // Simple mock server
        const originalFetch = window.fetch;
        window.fetch = async function(url, options) {
            console.log('üåê Mock fetch called:', url, options);
            
            // Simulate different responses
            if (url.includes('/api/test')) {
                return {
                    text: () => Promise.resolve('<p>Basic fetch success!</p>'),
                    status: 200
                };
            } else if (url.includes('/api/replace')) {
                return {
                    text: () => Promise.resolve('<div id="result2">Replaced content!</div>'),
                    status: 200
                };
            } else if (url.includes('/api/content')) {
                return {
                    text: () => Promise.resolve('New inner content'),
                    status: 200
                };
            } else if (url.includes('/api/append')) {
                return {
                    text: () => Promise.resolve('<p>Appended content</p>'),
                    status: 200
                };
            } else if (url.includes('/api/prepend')) {
                return {
                    text: () => Promise.resolve('<p>Prepended content</p>'),
                    status: 200
                };
            } else if (url.includes('/api/post')) {
                return {
                    text: () => Promise.resolve(`<p>POST received: ${options?.body || 'no body'}</p>`),
                    status: 200
                };
            } else if (url.includes('/api/events')) {
                return {
                    text: () => Promise.resolve('<p>Events test successful!</p>'),
                    status: 200
                };
            }
            
            // Fallback to real fetch
            return originalFetch(url, options);
        };
    </script>
    
    <!-- HyperFixi Integration -->
    <script>
        // HyperFixi: _hyperscript + fixi.js integration
        (function() {
            'use strict';
            
            console.log('üîß Loading HyperFixi integration...');
            
            // Ensure dependencies are loaded
            if (typeof _hyperscript === 'undefined') {
                console.error('‚ùå _hyperscript not found');
                return;
            }
            
            console.log('‚úÖ _hyperscript found:', _hyperscript.version);
            
            // Add the fetch command to hyperscript
            _hyperscript.addCommand('fetch', function(parser, runtime, tokens) {
                console.log('üîß Parsing fetch command...');
                
                // Parse the URL (required first argument)
                let url = parser.parseElementExpression();
                if (!url) {
                    parser.raiseParseError(tokens, "Expected URL after 'fetch'");
                }
                
                console.log('üìù Parsed URL expression');
                
                // Initialize command structure
                let command = {
                    url: url,
                    placement: null,
                    target: null,
                    options: {}
                };
                
                // Check what comes next to determine syntax form
                if (tokens.matchToken('with')) {
                    // Extended syntax: fetch /url with method: 'POST', body: data
                    command = parseExtendedSyntax(parser, runtime, tokens, command);
                } else {
                    // Shorthand syntax: fetch /url [and] <placement> <target>
                    command = parseShorthandSyntax(parser, runtime, tokens, command);
                }
                
                console.log('‚úÖ Command parsed:', command);
                
                // Return the runtime execution step
                return {
                    args: [command],
                    execute: function(ctx) {
                        return executeCommand.call(this, ctx, command, runtime);
                    }
                };
            });
            
            // Parse shorthand syntax: fetch /url [and] <placement> <target>
            function parseShorthandSyntax(parser, runtime, tokens, command) {
                // Optional 'and' connector
                tokens.matchToken('and');
                
                // Look for placement keywords
                if (tokens.matchToken('replace')) {
                    command.placement = 'replace';
                    command.target = parser.parseElementExpression();
                    console.log('üìù Parsed replace placement');
                } else if (tokens.matchToken('put')) {
                    if (!tokens.matchToken('into')) {
                        parser.raiseParseError(tokens, "Expected 'into' after 'put'");
                    }
                    command.placement = 'put into';
                    command.target = parser.parseElementExpression();
                    console.log('üìù Parsed put into placement');
                } else if (tokens.matchToken('append')) {
                    if (!tokens.matchToken('to')) {
                        parser.raiseParseError(tokens, "Expected 'to' after 'append'");
                    }
                    command.placement = 'append to';
                    command.target = parser.parseElementExpression();
                    console.log('üìù Parsed append to placement');
                } else if (tokens.matchToken('prepend')) {
                    if (!tokens.matchToken('to')) {
                        parser.raiseParseError(tokens, "Expected 'to' after 'prepend'");
                    }
                    command.placement = 'prepend to';
                    command.target = parser.parseElementExpression();
                    console.log('üìù Parsed prepend to placement');
                }
                
                return command;
            }
            
            // Parse extended syntax: fetch /url with option: value, option: value
            function parseExtendedSyntax(parser, runtime, tokens, command) {
                console.log('üìù Parsing extended syntax...');
                
                // Parse comma-separated options
                do {
                    // Look for known option names
                    let optionName = null;
                    if (tokens.matchToken('method')) {
                        optionName = 'method';
                    } else if (tokens.matchToken('body')) {
                        optionName = 'body';
                    } else if (tokens.matchToken('headers')) {
                        optionName = 'headers';
                    } else if (tokens.matchToken('target')) {
                        optionName = 'target';
                    } else if (tokens.matchToken('placement')) {
                        optionName = 'placement';
                    } else {
                        parser.raiseParseError(tokens, "Expected option name (method, body, headers, target, placement)");
                    }
                    
                    if (!tokens.matchToken(':')) {
                        parser.raiseParseError(tokens, "Expected ':' after option name");
                    }
                    
                    let optionValue = parser.parseElementExpression();
                    
                    // Store in appropriate place
                    if (optionName === 'target') {
                        command.target = optionValue;
                    } else if (optionName === 'placement') {
                        command.placement = optionValue;
                    } else {
                        command.options[optionName] = optionValue;
                    }
                    
                    console.log(`üìù Parsed option: ${optionName}`);
                    
                } while (tokens.matchToken(','));
                
                return command;
            }
            
            // Execute the fetch command
            async function executeCommand(ctx, command, runtime) {
                try {
                    console.log('üöÄ Executing fetch command:', command);
                    
                    // Get the triggering element
                    const element = ctx.me;
                    
                    // Evaluate dynamic expressions
                    const url = await runtime.resolve(command.url, ctx);
                    console.log('üåê Resolved URL:', url);
                    
                    // Build fixi-style config object
                    const cfg = {
                        url: url,
                        method: 'GET',
                        headers: {},
                        target: element,
                        swap: 'outerHTML',
                        trigger: ctx.event
                    };
                    
                    // Configure request options
                    if (command.options.method) {
                        cfg.method = await runtime.resolve(command.options.method, ctx);
                        console.log('üîß Method:', cfg.method);
                    }
                    
                    if (command.options.body) {
                        cfg.body = await runtime.resolve(command.options.body, ctx);
                        console.log('üì¶ Body:', cfg.body);
                    }
                    
                    if (command.options.headers) {
                        cfg.headers = { ...cfg.headers, ...await runtime.resolve(command.options.headers, ctx) };
                        console.log('üìã Headers:', cfg.headers);
                    }
                    
                    // Configure target and placement
                    if (command.target) {
                        cfg.target = await runtime.resolve(command.target, ctx);
                        console.log('üéØ Target element:', cfg.target);
                    }
                    
                    if (command.placement) {
                        const placement = typeof command.placement === 'string' ? 
                            command.placement : 
                            await runtime.resolve(command.placement, ctx);
                        
                        // Map placement to fixi swap method
                        switch (placement) {
                            case 'replace':
                                cfg.swap = 'outerHTML';
                                break;
                            case 'put into':
                                cfg.swap = 'innerHTML';
                                break;
                            case 'append to':
                                cfg.swap = 'beforeend';
                                break;
                            case 'prepend to':
                                cfg.swap = 'afterbegin';
                                break;
                            default:
                                cfg.swap = placement; // Allow custom swap methods
                        }
                    }
                    
                    // Emit fx:config event (fixi compatibility)
                    const configEvent = new CustomEvent('fx:config', {
                        detail: { cfg: cfg },
                        bubbles: true,
                        cancelable: true
                    });
                    
                    element.dispatchEvent(configEvent);
                    
                    if (configEvent.defaultPrevented) {
                        console.log('üö´ Request canceled by fx:config event');
                        return;
                    }
                    
                    // Emit fx:before event
                    const beforeEvent = new CustomEvent('fx:before', {
                        detail: { cfg: cfg },
                        bubbles: true,
                        cancelable: true
                    });
                    
                    element.dispatchEvent(beforeEvent);
                    
                    if (beforeEvent.defaultPrevented) {
                        console.log('üö´ Request canceled by fx:before event');
                        return;
                    }
                    
                    // Execute fetch with current config
                    const fetchOptions = {
                        method: cfg.method,
                        body: cfg.body,
                        headers: cfg.headers
                    };
                    
                    const response = await fetch(cfg.url, fetchOptions);
                    const text = await response.text();
                    
                    console.log('üì® Received response:', text);
                    
                    // Add response data to config
                    cfg.response = response;
                    cfg.text = text;
                    
                    // Emit fx:after event
                    const afterEvent = new CustomEvent('fx:after', {
                        detail: { cfg: cfg },
                        bubbles: true,
                        cancelable: true
                    });
                    
                    element.dispatchEvent(afterEvent);
                    
                    if (afterEvent.defaultPrevented) {
                        console.log('üö´ Swapping canceled by fx:after event');
                        return text; // Still return response for then clauses
                    }
                    
                    // Handle DOM manipulation using config
                    if (cfg.target && cfg.text) {
                        console.log('üéØ Swapping content using method:', cfg.swap);
                        
                        switch (cfg.swap) {
                            case 'outerHTML':
                                cfg.target.outerHTML = cfg.text;
                                console.log('üîÑ Replaced element');
                                break;
                            case 'innerHTML':
                                cfg.target.innerHTML = cfg.text;
                                console.log('üì• Put content into element');
                                break;
                            case 'beforeend':
                                cfg.target.insertAdjacentHTML('beforeend', cfg.text);
                                console.log('‚ûï Appended content');
                                break;
                            case 'afterbegin':
                                cfg.target.insertAdjacentHTML('afterbegin', cfg.text);
                                console.log('‚¨ÜÔ∏è Prepended content');
                                break;
                            default:
                                console.log('‚ÑπÔ∏è Custom swap method:', cfg.swap);
                                if (typeof cfg.swap === 'function') {
                                    cfg.swap(cfg);
                                } else {
                                    // Default to outerHTML
                                    cfg.target.outerHTML = cfg.text;
                                }
                        }
                        
                        // Emit fx:swapped event
                        const swappedEvent = new CustomEvent('fx:swapped', {
                            detail: { cfg: cfg },
                            bubbles: true
                        });
                        
                        // Dispatch on document if element was removed
                        try {
                            if (document.contains(element)) {
                                element.dispatchEvent(swappedEvent);
                            } else {
                                document.dispatchEvent(swappedEvent);
                            }
                        } catch (e) {
                            document.dispatchEvent(swappedEvent);
                        }
                    }
                    
                    console.log('‚úÖ Fetch completed successfully');
                    return text;
                    
                } catch (error) {
                    console.error('‚ùå Fetch error:', error);
                    
                    // Emit fx:error event (fixi compatibility)
                    const errorEvent = new CustomEvent('fx:error', {
                        detail: { 
                            error: error, 
                            cfg: cfg || { url: url }, 
                            command: command 
                        },
                        bubbles: true
                    });
                    
                    if (ctx.me) {
                        ctx.me.dispatchEvent(errorEvent);
                    }
                    
                    // Also emit fixi:error for hyperscript event handlers
                    const fixiErrorEvent = new CustomEvent('fixi:error', {
                        detail: { 
                            error: error, 
                            command: command 
                        },
                        bubbles: true
                    });
                    
                    if (ctx.me) {
                        ctx.me.dispatchEvent(fixiErrorEvent);
                    }
                    
                    throw error;
                } finally {
                    // Emit fx:finally event
                    if (cfg && ctx.me) {
                        const finallyEvent = new CustomEvent('fx:finally', {
                            detail: { cfg: cfg },
                            bubbles: true
                        });
                        
                        ctx.me.dispatchEvent(finallyEvent);
                    }
                }
            }
            
            console.log('‚úÖ HyperFixi integration loaded successfully');
            
        })();
    </script>
    
    <script>
        // Event logging for visualization
        const eventLog = [];
        
        function logEvent(eventName, element) {
            const timestamp = new Date().toLocaleTimeString();
            const message = `${timestamp}: ${eventName} on ${element.tagName}#${element.id || 'unknown'}`;
            eventLog.push(message);
            
            const logDiv = document.getElementById('event-log');
            if (logDiv) {
                logDiv.innerHTML = '<strong>Event Log:</strong><br>' + 
                    eventLog.slice(-5).map(msg => `<small>${msg}</small>`).join('<br>');
            }
        }
        
        // Listen for all fixi events
        ['fx:config', 'fx:before', 'fx:after', 'fx:error', 'fx:finally', 'fx:swapped', 'fixi:error'].forEach(eventName => {
            document.addEventListener(eventName, function(evt) {
                logEvent(eventName, evt.target);
                console.log(`üì° ${eventName}:`, evt.detail);
            });
        });
        
        // Test that hyperscript is working
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üìÑ DOM loaded, hyperscript version:', _hyperscript.version);
            
            // Process any unprocessed hyperscript elements
            _hyperscript.processNode(document.body);
            
            console.log('üîß Hyperscript processing complete');
        });
    </script>
</body>
</html>