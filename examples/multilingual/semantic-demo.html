<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic-First Multilingual Parsing - HyperFixi</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 40px 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tagline {
            font-size: 1.1rem;
            color: #888;
            margin-bottom: 20px;
        }

        .back-link {
            display: inline-block;
            color: #667eea;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 25px;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .back-link:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .card {
            background: #1e1e2e;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #2d2d3d;
        }

        .card h2 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card p {
            color: #888;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        /* Language input section */
        .input-section {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            color: #aaa;
            font-size: 0.9rem;
        }

        .input-group input, .input-group select {
            padding: 12px 15px;
            border: 2px solid #3d3d4d;
            border-radius: 8px;
            background: #2d2d3d;
            color: #fff;
            font-size: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group select {
            cursor: pointer;
        }

        /* Results grid */
        .results-grid {
            display: grid;
            gap: 15px;
        }

        .result-card {
            background: #252535;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #3d3d4d;
        }

        .result-header {
            background: #2d2d3d;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            border-bottom: 1px solid #3d3d4d;
        }

        .result-header .flag {
            font-size: 1.2rem;
        }

        .result-header .lang-name {
            color: #fff;
        }

        .result-header .badge {
            margin-left: auto;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-svo { background: #667eea; color: white; }
        .badge-sov { background: #e91e63; color: white; }
        .badge-vso { background: #28a745; color: white; }
        .badge-explicit { background: #ff9800; color: black; }

        .result-content {
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            color: #d4d4d4;
            line-height: 1.6;
        }

        .result-content.rtl {
            direction: rtl;
            text-align: right;
        }

        /* Semantic AST display */
        .semantic-display {
            background: #1a1a2a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            overflow-x: auto;
        }

        .semantic-display .key { color: #569cd6; }
        .semantic-display .value { color: #ce9178; }
        .semantic-display .role { color: #4ec9b0; }

        /* Quick examples */
        .examples-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .example-btn {
            padding: 8px 14px;
            border: 1px solid #3d3d4d;
            border-radius: 6px;
            background: #2d2d3d;
            color: #aaa;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .example-btn:hover {
            background: #3d3d4d;
            color: #fff;
            border-color: #667eea;
        }

        /* Architecture diagram */
        .architecture {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 30px;
            flex-wrap: wrap;
        }

        .arch-box {
            background: #2d2d3d;
            padding: 20px 25px;
            border-radius: 10px;
            text-align: center;
            min-width: 150px;
        }

        .arch-box.highlight {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .arch-arrow {
            color: #667eea;
            font-size: 24px;
        }

        /* Comparison table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .comparison-table th, .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #3d3d4d;
        }

        .comparison-table th {
            background: #2d2d3d;
            color: #fff;
            font-weight: 600;
        }

        .comparison-table td {
            color: #aaa;
        }

        .comparison-table tr:hover td {
            background: #252535;
        }

        /* Info box */
        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px 20px;
            border-radius: 0 8px 8px 0;
            margin-top: 20px;
        }

        .info-box strong {
            color: #667eea;
        }

        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            .architecture {
                flex-direction: column;
            }
            .arch-arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">‚Üê Back to Multilingual Demo</a>
            <h1>Semantic-First Parser</h1>
            <p class="tagline">Native-feeling syntax in every language, not translated English</p>
        </header>

        <!-- Architecture Overview -->
        <div class="card">
            <h2>How It Works</h2>
            <p>
                Unlike keyword translation, the semantic parser understands the <strong>meaning</strong> of your code.
                Each language has idiomatic patterns that feel natural to native speakers.
            </p>
            <div class="architecture">
                <div class="arch-box">
                    <div style="font-size: 24px; margin-bottom: 8px;">üáØüáµ üá∏üá¶ üá™üá∏</div>
                    <div>Native Input</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="arch-box">
                    <div style="font-size: 24px; margin-bottom: 8px;">üî§</div>
                    <div>Tokenizer</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="arch-box">
                    <div style="font-size: 24px; margin-bottom: 8px;">üéØ</div>
                    <div>Pattern Match</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="arch-box highlight">
                    <div style="font-size: 24px; margin-bottom: 8px;">üíé</div>
                    <div>Semantic AST</div>
                </div>
                <div class="arch-arrow">‚Üí</div>
                <div class="arch-box">
                    <div style="font-size: 24px; margin-bottom: 8px;">‚ö°</div>
                    <div>Runtime</div>
                </div>
            </div>
        </div>

        <!-- Live Parser Demo -->
        <div class="card">
            <h2>üîÑ Bidirectional Parser Demo</h2>
            <p>
                Enter hyperscript in <strong>any supported language</strong>. The parser extracts semantic meaning
                and can render to any other language. Try typing in Japanese, Arabic, or Spanish!
            </p>

            <div class="examples-row">
                <button class="example-btn" onclick="setExample('toggle .active on #button', 'en')">üá∫üá∏ toggle .active on #button</button>
                <button class="example-btn" onclick="setExample('#button „ÅÆ .active „Çí Âàá„ÇäÊõø„Åà', 'ja')">üáØüáµ #button „ÅÆ .active „Çí Âàá„ÇäÊõø„Åà</button>
                <button class="example-btn" onclick="setExample('ÿ®ÿØŸëŸÑ .active ÿπŸÑŸâ #button', 'ar')">üá∏üá¶ ÿ®ÿØŸëŸÑ .active ÿπŸÑŸâ #button</button>
                <button class="example-btn" onclick="setExample('alternar .active en #button', 'es')">üá™üá∏ alternar .active en #button</button>
                <button class="example-btn" onclick="setExample('put \"hello\" into #output', 'en')">üá∫üá∏ put "hello" into #output</button>
                <button class="example-btn" onclick="setExample('.active „Çí Âàá„ÇäÊõø„Åà', 'ja')">üáØüáµ .active „Çí Âàá„ÇäÊõø„Åà</button>
            </div>

            <div class="input-section">
                <div class="input-group">
                    <label>Input (any supported language)</label>
                    <input type="text" id="parser-input" value="toggle .active on #button" placeholder="Enter hyperscript...">
                </div>
                <div class="input-group">
                    <label>Source Language</label>
                    <select id="source-lang">
                        <option value="en">üá∫üá∏ English</option>
                        <option value="ja">üáØüáµ Japanese</option>
                        <option value="ar">üá∏üá¶ Arabic</option>
                        <option value="es">üá™üá∏ Spanish</option>
                    </select>
                </div>
            </div>

            <!-- Semantic AST -->
            <h3 style="color: #fff; margin-bottom: 10px; font-size: 1rem;">Semantic Representation (Language-Neutral)</h3>
            <div class="semantic-display" id="semantic-output">
                <!-- Filled by JS -->
            </div>

            <!-- Translations -->
            <h3 style="color: #fff; margin: 20px 0 10px; font-size: 1rem;">Rendered in All Languages</h3>
            <div class="results-grid" id="translations-output">
                <!-- Filled by JS -->
            </div>
        </div>

        <!-- Explicit Mode -->
        <div class="card">
            <h2>üîç Explicit Mode</h2>
            <p>
                A universal syntax that makes semantic roles visible. Perfect for learning, debugging,
                and documentation. Same in all languages!
            </p>

            <div class="examples-row">
                <button class="example-btn" onclick="showExplicit('[toggle patient:.active destination:#button]')">[toggle patient:.active destination:#button]</button>
                <button class="example-btn" onclick="showExplicit('[put patient:\"hello\" destination:#output]')">[put patient:"hello" destination:#output]</button>
                <button class="example-btn" onclick="showExplicit('[on event:click body:[toggle patient:.active]]')">[on event:click ...]</button>
            </div>

            <div class="input-group" style="margin-bottom: 20px;">
                <label>Explicit Syntax</label>
                <input type="text" id="explicit-input" value="[toggle patient:.active destination:#button]" placeholder="[command role:value ...]">
            </div>

            <h3 style="color: #fff; margin-bottom: 10px; font-size: 1rem;">Converts To Natural Language</h3>
            <div class="results-grid" id="explicit-output">
                <!-- Filled by JS -->
            </div>

            <div class="info-box">
                <strong>Semantic Roles:</strong> The explicit syntax shows the underlying meaning.
                <code>patient</code> is what's being acted on, <code>destination</code> is where,
                <code>source</code> is from where, <code>event</code> is what triggers it.
            </div>
        </div>

        <!-- Pattern Examples -->
        <div class="card">
            <h2>üìù Native Patterns by Language</h2>
            <p>
                Each language has patterns that feel natural to native speakers, not just translated keywords.
            </p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Language</th>
                        <th>Word Order</th>
                        <th>Toggle Pattern</th>
                        <th>Natural Feel</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>üá∫üá∏ English</td>
                        <td><span class="badge badge-svo">SVO</span></td>
                        <td><code>toggle .active on #button</code></td>
                        <td>Verb first, optional target</td>
                    </tr>
                    <tr>
                        <td>üáØüáµ Japanese</td>
                        <td><span class="badge badge-sov">SOV</span></td>
                        <td><code>#button „ÅÆ .active „Çí Âàá„ÇäÊõø„Åà</code></td>
                        <td>"button's active, toggle" - object before verb</td>
                    </tr>
                    <tr>
                        <td>üá∏üá¶ Arabic</td>
                        <td><span class="badge badge-vso">VSO</span></td>
                        <td><code>ÿ®ÿØŸëŸÑ .active ÿπŸÑŸâ #button</code></td>
                        <td>Verb first, RTL text</td>
                    </tr>
                    <tr>
                        <td>üá™üá∏ Spanish</td>
                        <td><span class="badge badge-svo">SVO</span></td>
                        <td><code>alternar .active en #button</code></td>
                        <td>Similar to English structure</td>
                    </tr>
                </tbody>
            </table>

            <div class="info-box" style="margin-top: 20px;">
                <strong>Key Insight:</strong> Japanese uses particles („Çí, „ÅÆ, „Å´) to mark grammatical roles,
                so word order is flexible. Arabic is RTL but CSS selectors remain LTR "islands".
                The semantic parser understands these linguistic features natively.
            </div>
        </div>
    </div>

    <!-- Load the semantic package (IIFE bundle) -->
    <script src="../../packages/semantic/dist/browser.global.js"></script>
    <script>
        // Using the real HyperFixiSemantic bundle!
        const Semantic = window.HyperFixiSemantic;

        // Check if bundle loaded
        if (!Semantic) {
            console.error('HyperFixiSemantic bundle not loaded!');
            document.body.innerHTML = '<h1 style="color: red; text-align: center; margin-top: 100px;">Error: Semantic bundle not loaded. Run "npm run build:browser" in packages/semantic/</h1>';
        } else {
            console.log('HyperFixiSemantic loaded:', Semantic.VERSION || 'unknown version');
            console.log('Supported languages:', Semantic.getSupportedLanguages ? Semantic.getSupportedLanguages() : 'API not available');
        }

        const languages = {
            en: { name: 'English', flag: 'üá∫üá∏', wordOrder: 'SVO', rtl: false },
            ja: { name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ', wordOrder: 'SOV', rtl: false },
            ar: { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶', wordOrder: 'VSO', rtl: true },
            es: { name: 'Espa√±ol', flag: 'üá™üá∏', wordOrder: 'SVO', rtl: false },
        };

        function updateParserDemo() {
            const input = document.getElementById('parser-input').value.trim();
            const sourceLang = document.getElementById('source-lang').value;
            const semanticOutput = document.getElementById('semantic-output');
            const translationsOutput = document.getElementById('translations-output');

            if (!input) {
                semanticOutput.innerHTML = `<span style="color: #888;">Enter a command to see semantic analysis</span>`;
                translationsOutput.innerHTML = `<div style="color: #888; padding: 20px; text-align: center;">Enter a command above to see translations.</div>`;
                return;
            }

            try {
                // Parse using the real semantic parser
                const parseResult = Semantic.parse(input, sourceLang);

                if (!parseResult || parseResult.confidence === 0) {
                    semanticOutput.innerHTML = `<span style="color: #f44;">Parse failed or low confidence</span>
<span style="color: #888;">Input: "${escapeHtml(input)}"</span>
<span style="color: #888;">Language: ${sourceLang}</span>`;
                    translationsOutput.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">Could not parse input. Try a different pattern or check the syntax.</div>`;
                    return;
                }

                // Display semantic representation
                const semantic = parseResult.semantic || parseResult;
                const rolesObj = semantic.roles || {};
                let rolesHtml = '';

                if (rolesObj instanceof Map) {
                    for (const [role, value] of rolesObj) {
                        const valueStr = formatSemanticValue(value);
                        rolesHtml += `    <span class="role">${role}</span>: <span class="value">${valueStr}</span>,\n`;
                    }
                } else if (typeof rolesObj === 'object') {
                    for (const [role, value] of Object.entries(rolesObj)) {
                        const valueStr = formatSemanticValue(value);
                        rolesHtml += `    <span class="role">${role}</span>: <span class="value">${valueStr}</span>,\n`;
                    }
                }

                // Get explicit syntax
                let explicitStr = '';
                try {
                    // toExplicit takes (input, language), not the parseResult
                    explicitStr = Semantic.toExplicit ? Semantic.toExplicit(input, sourceLang) : '[explicit not available]';
                } catch (e) {
                    console.error('toExplicit error:', e);
                    explicitStr = '[error generating explicit]';
                }

                semanticOutput.innerHTML = `{
  <span class="key">action</span>: <span class="value">"${semantic.action || semantic.type || 'unknown'}"</span>,
  <span class="key">confidence</span>: <span class="value">${(parseResult.confidence || 0).toFixed(2)}</span>,
  <span class="key">roles</span>: {
${rolesHtml}  },
  <span class="key">explicit</span>: <span class="value">"${escapeHtml(explicitStr)}"</span>
}`;

                // Generate translations to all languages
                let translationsHtml = '';

                for (const [code, lang] of Object.entries(languages)) {
                    let translation = input; // Default to input
                    try {
                        if (Semantic.render) {
                            translation = Semantic.render(parseResult, code);
                        } else if (Semantic.translate && code !== sourceLang) {
                            translation = Semantic.translate(input, sourceLang, code);
                        }
                    } catch (e) {
                        console.warn(`Translation to ${code} failed:`, e);
                        translation = `[error: ${e.message}]`;
                    }

                    const badgeClass = lang.wordOrder === 'SVO' ? 'badge-svo' : lang.wordOrder === 'SOV' ? 'badge-sov' : 'badge-vso';
                    const isSource = code === sourceLang;

                    translationsHtml += `
                        <div class="result-card" ${isSource ? 'style="border-color: #667eea;"' : ''}>
                            <div class="result-header">
                                <span class="flag">${lang.flag}</span>
                                <span class="lang-name">${lang.name}</span>
                                ${isSource ? '<span class="badge" style="background: #667eea; color: white;">SOURCE</span>' : ''}
                                <span class="badge ${badgeClass}">${lang.wordOrder}</span>
                            </div>
                            <div class="result-content ${lang.rtl ? 'rtl' : ''}">${escapeHtml(translation)}</div>
                        </div>
                    `;
                }

                // Add explicit mode
                translationsHtml += `
                    <div class="result-card">
                        <div class="result-header">
                            <span class="flag">üîß</span>
                            <span class="lang-name">Explicit Mode</span>
                            <span class="badge badge-explicit">Universal</span>
                        </div>
                        <div class="result-content">${escapeHtml(explicitStr)}</div>
                    </div>
                `;

                translationsOutput.innerHTML = translationsHtml;

            } catch (error) {
                console.error('Parse error:', error);
                semanticOutput.innerHTML = `<span style="color: #f44;">Error: ${escapeHtml(error.message)}</span>`;
                translationsOutput.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">Parse error occurred. Check console for details.</div>`;
            }
        }

        function formatSemanticValue(value) {
            if (value === null || value === undefined) return 'null';
            if (typeof value === 'string') return `"${escapeHtml(value)}"`;
            if (typeof value === 'object') {
                if (value.type === 'selector') return `selector("${value.value}")`;
                if (value.type === 'literal') return `literal(${JSON.stringify(value.value)})`;
                if (value.type === 'reference') return `ref(${value.name})`;
                return JSON.stringify(value);
            }
            return String(value);
        }

        function updateExplicitDemo() {
            const input = document.getElementById('explicit-input').value.trim();
            const output = document.getElementById('explicit-output');

            if (!input) {
                output.innerHTML = `<div style="color: #888; padding: 20px; text-align: center;">Enter explicit syntax to see renderings.</div>`;
                return;
            }

            try {
                // Try to parse explicit syntax
                if (!Semantic.parseExplicit) {
                    output.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">parseExplicit not available in bundle</div>`;
                    return;
                }

                const parsed = Semantic.parseExplicit(input);

                if (!parsed) {
                    output.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">Could not parse explicit syntax</div>`;
                    return;
                }

                let html = '';
                for (const [code, lang] of Object.entries(languages)) {
                    let translation = '';
                    try {
                        translation = Semantic.render ? Semantic.render(parsed, code) : '[render not available]';
                    } catch (e) {
                        translation = `[error: ${e.message}]`;
                    }

                    const badgeClass = lang.wordOrder === 'SVO' ? 'badge-svo' : lang.wordOrder === 'SOV' ? 'badge-sov' : 'badge-vso';

                    html += `
                        <div class="result-card">
                            <div class="result-header">
                                <span class="flag">${lang.flag}</span>
                                <span class="lang-name">${lang.name}</span>
                                <span class="badge ${badgeClass}">${lang.wordOrder}</span>
                            </div>
                            <div class="result-content ${lang.rtl ? 'rtl' : ''}">${escapeHtml(translation)}</div>
                        </div>
                    `;
                }

                output.innerHTML = html;

            } catch (error) {
                console.error('Explicit parse error:', error);
                output.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">Error: ${escapeHtml(error.message)}</div>`;
            }
        }

        // Helper functions
        function setExample(text, lang) {
            document.getElementById('parser-input').value = text;
            document.getElementById('source-lang').value = lang;
            updateParserDemo();
        }

        function showExplicit(text) {
            document.getElementById('explicit-input').value = text;
            updateExplicitDemo();
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Set up event listeners
            document.getElementById('parser-input').addEventListener('input', updateParserDemo);
            document.getElementById('source-lang').addEventListener('change', updateParserDemo);
            document.getElementById('explicit-input').addEventListener('input', updateExplicitDemo);

            // Initial render
            updateParserDemo();
            updateExplicitDemo();
        });

        // Expose functions globally for onclick handlers
        window.setExample = setExample;
        window.showExplicit = showExplicit;
    </script>
</body>
</html>
