<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04: Infinite Scroll - HyperFixi Examples</title>
    <link rel="stylesheet" href="../gallery.css">
    <style>
        /* Example-specific styles */
        .scroll-container {
            max-height: 600px;
            overflow-y: auto;
            border: 2px solid var(--color-border, #e4e4e7);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .content-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .content-item {
            background: linear-gradient(135deg, var(--color-surface, #e3f2fd) 0%, #bbdefb 100%);
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .item-number {
            background: var(--color-accent, #6366f1);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .item-timestamp {
            color: var(--color-text-muted, #71717a);
            font-size: 14px;
        }

        .item-title {
            font-weight: bold;
            color: var(--color-text, #18181b);
            font-size: 18px;
            margin: 10px 0;
        }

        .item-description {
            color: var(--color-text-muted, #71717a);
            line-height: 1.6;
        }

        .loading-indicator {
            text-align: center;
            padding: 30px;
            color: var(--color-accent, #6366f1);
            font-size: 18px;
            display: none;
        }

        .loading-indicator.active {
            display: block;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--color-border, #e4e4e7);
            border-top-color: var(--color-accent, #6366f1);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .end-message {
            text-align: center;
            padding: 30px;
            color: var(--color-text-muted, #71717a);
            font-size: 16px;
            display: none;
        }

        .end-message.show {
            display: block;
        }

        .stats {
            background: var(--color-surface, #f4f4f5);
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat-item {
            flex: 1;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--color-accent, #6366f1);
        }

        .stat-label {
            color: var(--color-text-muted, #71717a);
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
</head>
<body class="example-page">
    <div class="page-container">
        <div class="breadcrumb">
            <a href="../index.html">← Back to Gallery</a> / <strong>Advanced</strong> / 04: Infinite Scroll
        </div>

        <h1>Infinite Scroll</h1>

        <div class="description">
            <strong>Load content dynamically as users scroll</strong><br>
            Learn how to implement infinite scroll patterns using hyperscript's scroll events
            and intersection observers. Perfect for feeds, news lists, and content-heavy pages!
        </div>

        <div>
            <span class="tag">scroll</span>
            <span class="tag">intersection</span>
            <span class="tag">dynamic loading</span>
            <span class="tag">async</span>
        </div>

        <!-- Demo -->
        <div class="demo">
            <h2>Infinite News Feed</h2>
            <p>Scroll to the bottom to load more items automatically:</p>

            <div class="stats">
                <div class="stat-item">
                    <div id="items-loaded" class="stat-value">10</div>
                    <div class="stat-label">Items Loaded</div>
                </div>
                <div class="stat-item">
                    <div id="total-loads" class="stat-value">1</div>
                    <div class="stat-label">Load Count</div>
                </div>
                <div class="stat-item">
                    <div id="scroll-position" class="stat-value">0%</div>
                    <div class="stat-label">Scroll Position</div>
                </div>
            </div>

            <div class="scroll-container"
                 _="init
                      set :currentPage to 1
                      set :maxPages to 10
                      set :loading to false
                      set :itemCount to 10
                    end

                    on scroll
                      -- Calculate scroll position percentage
                      set scrollTop to my scrollTop
                      set scrollHeight to my scrollHeight
                      set clientHeight to my clientHeight
                      set scrollPercent to Math.round((scrollTop / (scrollHeight - clientHeight)) * 100)
                      put scrollPercent + '%' into #scroll-position

                      -- Check if near bottom (within 100px)
                      set distanceFromBottom to scrollHeight - (scrollTop + clientHeight)

                      if distanceFromBottom < 100 and :loading is false and :currentPage < :maxPages
                        set :loading to true
                        add .active to #loading

                        -- Simulate API call delay
                        wait 1.5s

                        -- Load more items
                        increment :currentPage
                        increment :itemCount by 10

                        -- Generate new items
                        repeat 10 times index i
                          set itemNum to (:currentPage - 1) * 10 + i + 1
                          set timestamp to new Date().toLocaleTimeString()
                          make a <li class='content-item'>
                            <div class='item-header'>
                              <span class='item-number'>#{itemNum}</span>
                              <span class='item-timestamp'>{timestamp}</span>
                            </div>
                            <div class='item-title'>Article Title #{itemNum}</div>
                            <div class='item-description'>
                              This is a dynamically loaded article. Lorem ipsum dolor sit amet,
                              consectetur adipiscing elit. Loaded on page {itemNum}.
                            </div>
                          </li> called newItem
                          put newItem at end of #content-list
                        end

                        -- Update stats
                        put :itemCount into #items-loaded
                        put :currentPage into #total-loads

                        remove .active from #loading
                        set :loading to false

                        -- Show end message if at max pages
                        if :currentPage >= :maxPages
                          add .show to #end-message
                        end
                      end
                    end">

                <ul id="content-list" class="content-list">
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#1</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Welcome to Infinite Scroll</div>
                        <div class="item-description">
                            Scroll down to load more articles automatically. This example demonstrates
                            how to implement infinite scroll using hyperscript's scroll event handling.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#2</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">How Infinite Scroll Works</div>
                        <div class="item-description">
                            The scroll event monitors your position in the container. When you get close
                            to the bottom, new content is automatically fetched and added to the list.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#3</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Performance Considerations</div>
                        <div class="item-description">
                            This implementation uses a loading flag to prevent multiple simultaneous loads.
                            It also calculates distance from bottom to trigger loading at the right time.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#4</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Dynamic Content Generation</div>
                        <div class="item-description">
                            New items are created using hyperscript's template literals and make command.
                            Each item includes a unique number, timestamp, and content.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#5</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">User Experience</div>
                        <div class="item-description">
                            Loading indicators provide feedback during content fetching. The scroll position
                            percentage helps users understand their position in the content.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#6</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">State Management</div>
                        <div class="item-description">
                            Local state variables track the current page, loading status, and total items.
                            This ensures consistent behavior across multiple load cycles.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#7</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Pagination Alternative</div>
                        <div class="item-description">
                            Infinite scroll is a modern alternative to traditional pagination. It's perfect
                            for social media feeds, news sites, and content discovery platforms.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#8</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Accessibility</div>
                        <div class="item-description">
                            Always provide keyboard navigation and screen reader announcements for
                            dynamically loaded content. Consider a "load more" button as a fallback.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#9</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Keep Scrolling!</div>
                        <div class="item-description">
                            Scroll down to see the infinite scroll in action. New content will load
                            automatically as you approach the bottom of the container.
                        </div>
                    </li>
                    <li class="content-item">
                        <div class="item-header">
                            <span class="item-number">#10</span>
                            <span class="item-timestamp">Initial Load</span>
                        </div>
                        <div class="item-title">Almost There...</div>
                        <div class="item-description">
                            Just a few more scrolls and you'll trigger the first automatic load.
                            Watch the loading indicator appear and new items slide in smoothly!
                        </div>
                    </li>
                </ul>

                <div id="loading" class="loading-indicator">
                    <div class="loading-spinner"></div>
                    <div>Loading more items...</div>
                </div>

                <div id="end-message" class="end-message">
                    You've reached the end! No more items to load.
                </div>
            </div>

            <button _="on click
                      call #content-list.querySelectorAll('.content-item').forEach(
                        function(item, i) { if (i >= 10) item.remove(); }
                      )
                      get #scroll-container
                      set result's :currentPage to 1
                      set result's :itemCount to 10
                      put '10' into #items-loaded
                      put '1' into #total-loads
                      remove .show from #end-message
                      set #scroll-container.scrollTop to 0">
                Reset Demo
            </button>
        </div>

        <!-- Code Explanation -->
        <h2>The Code</h2>

        <h3>Infinite Scroll Container:</h3>
        <div class="code">
&lt;div <span class="keyword">class</span>=<span class="string">"scroll-container"</span>
     <span class="keyword">_</span>=<span class="string">"init
           set :currentPage to 1
           set :maxPages to 10
           set :loading to false
         end

         on scroll
           set scrollTop to my scrollTop
           set scrollHeight to my scrollHeight
           set clientHeight to my clientHeight
           set distanceFromBottom to scrollHeight - (scrollTop + clientHeight)

           if distanceFromBottom < 100 and :loading is false
             set :loading to true
             add .active to #loading

             -- Simulate API call
             wait 1.5s

             -- Load more items
             increment :currentPage
             repeat 10 times
               make a &lt;li&gt;New Item&lt;/li&gt; called newItem
               put newItem at end of #content-list
             end

             remove .active from #loading
             set :loading to false
           end
         end"</span>&gt;
  &lt;ul <span class="keyword">id</span>=<span class="string">"content-list"</span>&gt;
    <span class="comment">&lt;!-- Initial items --&gt;</span>
  &lt;/ul&gt;
  &lt;div <span class="keyword">id</span>=<span class="string">"loading"</span> <span class="keyword">class</span>=<span class="string">"loading-indicator"</span>&gt;Loading...&lt;/div&gt;
&lt;/div&gt;
        </div>

        <h3>With API Fetching:</h3>
        <div class="code">
&lt;div <span class="keyword">_</span>=<span class="string">"on scroll
       set distanceFromBottom to
         my scrollHeight - (my scrollTop + my clientHeight)

       if distanceFromBottom < 100 and :loading is false
         set :loading to true

         fetch `/api/items?page=${:currentPage}` as json
         put result into items

         repeat for item in items
           make a &lt;li&gt;${item.title}&lt;/li&gt; called newItem
           put newItem at end of #list
         end

         increment :currentPage
         set :loading to false
       end"</span>&gt;
&lt;/div&gt;
        </div>

        <div class="explanation">
            <h3>How it works:</h3>
            <ul>
                <li><code>on scroll</code> - Fired when user scrolls the container</li>
                <li><code>scrollTop</code> - Current scroll position from top</li>
                <li><code>scrollHeight</code> - Total scrollable height</li>
                <li><code>clientHeight</code> - Visible height of container</li>
                <li><code>distanceFromBottom</code> - Pixels remaining to bottom</li>
                <li><code>:loading</code> - State variable to prevent duplicate loads</li>
            </ul>

            <h3>Key Concepts:</h3>
            <ul>
                <li><strong>Scroll Detection:</strong> Monitor scroll position to trigger loads</li>
                <li><strong>State Management:</strong> Use local variables to track loading state</li>
                <li><strong>Threshold Distance:</strong> Load content before reaching absolute bottom</li>
                <li><strong>Loading Flags:</strong> Prevent multiple simultaneous requests</li>
                <li><strong>Dynamic Content:</strong> Generate and append new DOM elements</li>
            </ul>

            <h3>Scroll Calculations:</h3>
            <div class="code">
<span class="comment">-- Get scroll metrics</span>
set scrollTop to element.scrollTop
set scrollHeight to element.scrollHeight
set clientHeight to element.clientHeight

<span class="comment">-- Calculate distance from bottom</span>
set distanceFromBottom to scrollHeight - (scrollTop + clientHeight)

<span class="comment">-- Calculate scroll percentage</span>
set scrollPercent to (scrollTop / (scrollHeight - clientHeight)) * 100

<span class="comment">-- Check if near bottom (within 100px)</span>
if distanceFromBottom < 100
  <span class="comment">-- Load more content</span>
end
            </div>

            <h3>Advanced Patterns:</h3>
            <div class="code">
<span class="comment">&lt;!-- Intersection Observer (more efficient) --&gt;</span>
&lt;div <span class="keyword">id</span>=<span class="string">"sentinel"</span>
     <span class="keyword">_</span>=<span class="string">"init
          set observer to new IntersectionObserver(
            function(entries) {
              if (entries[0].isIntersecting) {
                // Load more content
              }
            }
          )
          call observer.observe(me)
        end"</span>&gt;
&lt;/div&gt;

<span class="comment">&lt;!-- Virtual scrolling for large lists --&gt;</span>
&lt;div <span class="keyword">_</span>=<span class="string">"on scroll
       set visibleStart to Math.floor(scrollTop / itemHeight)
       set visibleEnd to visibleStart + visibleCount

       -- Only render visible items
       for i from visibleStart to visibleEnd
         if not #{i} exists
           make item for index i
           put it into #list
         end
       end"</span>&gt;
&lt;/div&gt;

<span class="comment">&lt;!-- Debounced scroll handling --&gt;</span>
&lt;div <span class="keyword">_</span>=<span class="string">"on scroll
       if :scrollTimer then clearTimeout(:scrollTimer) end
       set :scrollTimer to setTimeout(
         function() { checkLoadMore() },
         200
       )"</span>&gt;
&lt;/div&gt;

<span class="comment">&lt;!-- Bidirectional infinite scroll --&gt;</span>
&lt;div <span class="keyword">_</span>=<span class="string">"on scroll
       if scrollTop < 100
         -- Load older content at top
         fetch `/api/items?page=${:prevPage--}` as json
         for item in result
           make &lt;li&gt;{item}&lt;/li&gt;
           put it at start of #list
         end
       else if distanceFromBottom < 100
         -- Load newer content at bottom
         fetch `/api/items?page=${:nextPage++}` as json
         for item in result
           make &lt;li&gt;{item}&lt;/li&gt;
           put it at end of #list
         end
       end"</span>&gt;
&lt;/div&gt;
            </div>

            <h3>Common Use Cases:</h3>
            <ul>
                <li><strong>Social Media Feeds:</strong> Twitter, Facebook, Instagram style feeds</li>
                <li><strong>News Sites:</strong> Continuous article browsing</li>
                <li><strong>Image Galleries:</strong> Pinterest-style infinite grid</li>
                <li><strong>Search Results:</strong> Load more results as user scrolls</li>
                <li><strong>Chat History:</strong> Load older messages when scrolling up</li>
                <li><strong>Product Listings:</strong> E-commerce infinite browse</li>
            </ul>

            <h3>Performance Best Practices:</h3>
            <ul>
                <li>Use Intersection Observer API for better performance than scroll events</li>
                <li>Implement virtual scrolling for very large lists (1000+ items)</li>
                <li>Debounce scroll events to reduce event handler calls</li>
                <li>Remove off-screen items to manage memory</li>
                <li>Cache loaded pages to avoid redundant API calls</li>
                <li>Show loading indicators for better UX</li>
            </ul>

            <h3>Accessibility Considerations:</h3>
            <ul>
                <li>Announce new content to screen readers with <code>aria-live</code></li>
                <li>Provide a "Load More" button as keyboard-accessible alternative</li>
                <li>Include skip links to footer/end content</li>
                <li>Preserve scroll position on page navigation</li>
                <li>Allow users to disable infinite scroll</li>
            </ul>

            <h3>Try it yourself:</h3>
            <ul>
                <li>Connect to a real API (JSONPlaceholder, your backend, etc.)</li>
                <li>Add error handling for failed requests</li>
                <li>Implement virtual scrolling for performance</li>
                <li>Create bidirectional scroll (load both up and down)</li>
                <li>Add pull-to-refresh at the top</li>
                <li>Persist scroll position in localStorage</li>
            </ul>
        </div>

        <!-- Navigation -->
        <div class="nav-buttons">
            <a href="03-sortable-list.html">← Previous: Sortable List</a>
            <a href="05-state-machine.html">Next: State Machine →</a>
        </div>
    </div>

    <!-- Load HyperFixi -->
    <script src="../../packages/core/dist/hyperfixi-browser.js"></script>
    <script src="../prism-loader.js"></script>
    <script src="../debug-panel.js"></script>
</body>
</html>
